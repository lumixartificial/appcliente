<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="LUMIX Cliente">
    <meta name="theme-color" content="#6f42c1">
    <link rel="manifest" href="manifest-cliente.json">
    <link rel="icon" href="https://res.cloudinary.com/dc6as14p0/image/upload/v1759873183/LOGO_LUMIX_REDUCI_czkw4p.png" type="image/png">
    <link rel="apple-touch-icon" href="https://res.cloudinary.com/dc6as14p0/image/upload/v1759873183/LOGO_LUMIX_REDUCI_czkw4p.png">
    <title>Portal do Cliente</title>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
    <style>
        :root {
            --bg: #f8f9fa;
            --surface: #ffffff;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --accent-green: #28a745;
            --accent-yellow: #facc15;
            --accent-orange: #fb923c;
            --accent-purple: #6f42c1;
            --accent-purple-darker: #5a349c;
            --border-color: #e9ecef;
            --danger-color: #dc3545;
        }
        body.dark-mode {
            --bg: #020617;
            --surface: #0f172a;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border-color: #1e293b;
            --danger-color: #f87171;
            --accent-yellow: #fde047;
            --accent-orange: #fdba74;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; 
            width: 100%;
            height: 100%; 
            height: -webkit-fill-available;
            height: 100dvh;
        }
        body { font-family: 'Inter', sans-serif; background-color: var(--bg); color: var(--text-primary); transition: background-color 0.3s, color 0.3s; }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 0.9; }
        }

        @keyframes subtle-glow {
          0%, 100% {
            filter: drop-shadow(0 0 8px rgba(138, 43, 226, 0.7));
          }
          50% {
            filter: drop-shadow(0 0 16px rgba(57, 255, 20, 0.7));
          }
        }

        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease-out;
        }
        #splash-screen img {
            width: 150px; 
            height: 150px; 
            animation: pulse 2.5s infinite ease-in-out;
        }

        #login-view {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 20px;
            background-color: var(--bg);
        }
        .login-card {
            background-color: transparent;
            box-shadow: none;
            border: none;
            width: 100%; max-width: 400px; text-align: center;
        }
        .login-card .logo {
            display: flex;
            justify-content: center;
        }
        .login-card .logo img {
            width: 140px; 
            height: 140px; 
            margin-bottom: 30px; 
            animation: subtle-glow 5s ease-in-out infinite;
        }
        .login-card h2 {
            margin-bottom: 10px;
            font-size: 1.8em; 
            font-weight: 700;
            color: var(--text-primary);
        }
        .login-card p {
            margin-bottom: 40px;
            color: var(--text-secondary);
        }
        .login-card .form-group {
            text-align: left;
            margin-bottom: 20px;
        }
        .login-card .form-group label {
             display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary);
        }
        .login-card .form-group input { 
            width: 100%; 
            padding: 15px; 
            font-size: 1em; 
            border-radius: 8px; 
            border: 1px solid #334155; 
            background-color: #1e293b; 
            color: var(--text-primary); 
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .login-card .form-group input:focus {
            border-color: var(--accent-purple);
            outline: none;
            box-shadow: 0 0 0 3px rgba(111, 66, 193, 0.3);
        }

        .login-card .btn-primary {
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: var(--accent-purple);
            color: white;
            transition: background-color 0.2s;
        }
        .login-card .btn-primary:hover {
            background-color: var(--accent-purple-darker);
        }

        #app-container { 
            display: none;
            flex-direction: column;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            height: 100%;
            height: -webkit-fill-available;
            height: 100dvh;
        }
        main {
            flex-grow: 1; 
            overflow-y: auto; 
        }
        .container { padding: 20px; }
        
        .main-header { display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; background-color: var(--surface); border-bottom: 1px solid var(--border-color); position: sticky; top: 0; z-index: 100; transition: background-color 0.3s, border-color 0.3s; flex-shrink: 0; }
        .logo { display: flex; align-items: center; gap: 10px; }
        .logo img { height: 40px; width: 40px; object-fit: cover; }
        .logo-text { font-size: 1.2em; font-weight: 700; color: var(--text-primary); }
        .header-controls { display: flex; align-items: center; gap: 10px; }
        .header-btn { background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 5px; border-radius: 50%; display: flex; align-items: center; justify-content: center; position: relative; }
        #header-profile-img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border-color);
        }
        .profile {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .profile-info {
            font-weight: 500;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        .lang-dropdown { 
            display: none; 
            position: absolute; 
            top: 55px; 
            right: 10px; 
            background-color: var(--surface); 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
            z-index: 110; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            padding: 5px;
            width: 150px;
        }
        .lang-dropdown button { 
            background-color: transparent; 
            border: none; 
            color: var(--text-primary); 
            padding: 8px 12px; 
            border-radius: 6px; 
            cursor: pointer; 
            font-weight: 500; 
            width: 100%;
            text-align: left;
            box-shadow: none;
        }
        .lang-dropdown button:hover { background-color: var(--border-color); }
        .section-title { font-size: 1.2em; font-weight: 600; margin-bottom: 15px; color: var(--text-primary); }
        .kpi-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }
        .kpi-card { background-color: var(--surface); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); border: 1px solid var(--border-color); transition: background-color 0.3s, border-color 0.3s; }
        body.dark-mode .kpi-card { box-shadow: none; }
        .kpi-title { display: flex; align-items: center; gap: 8px; font-size: 0.9em; color: var(--text-secondary); margin: 0 0 10px; }
        .kpi-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
            white-space: nowrap;
        }
        .kpi-value.green { color: var(--accent-green); }
        .kpi-value.purple { color: var(--accent-purple); }

        .progress-card { text-align: center; }
        .progress-circle { position: relative; width: 120px; height: 120px; margin: 0 auto 15px; }
        .progress-circle svg { width: 100%; height: 100%; transform: rotate(-90deg); }
        .progress-circle circle { fill: none; stroke-width: 10; }
        .progress-circle .bg-circle { stroke: var(--border-color); }
        .progress-circle .progress-bar { stroke: var(--accent-purple); stroke-linecap: round; transition: stroke-dashoffset 1s ease-out; }
        .progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.5em; font-weight: 700; }
        
        .reputation-card { padding-bottom: 10px; }
        .reputation-bar-container { width: 100%; background-color: var(--border-color); border-radius: 8px; height: 16px; overflow: hidden; margin-bottom: 10px; }
        .reputation-bar { height: 100%; border-radius: 8px; width: 0%; transition: width 1s ease-out, background-color 0.5s; }
        .reputation-bar.status-perfect { background-color: var(--accent-green); }
        .reputation-bar.status-good { background-color: var(--accent-orange); }
        .reputation-bar.status-regular { background-color: var(--accent-yellow); }
        .reputation-bar.status-bad { background-color: var(--danger-color); }
        .reputation-status { display: flex; justify-content: space-between; align-items: center; font-size: 0.9em; }
        .reputation-value { font-weight: 700; }
        .reputation-text { font-weight: 500; padding: 2px 8px; border-radius: 10px; }
        .reputation-text.status-perfect { color: var(--accent-green); background-color: rgba(40, 167, 69, 0.1); }
        .reputation-text.status-good { color: #b45309; background-color: rgba(251, 146, 60, 0.15); }
        body.dark-mode .reputation-text.status-good { color: var(--accent-orange); background-color: rgba(253, 186, 116, 0.1); }
        .reputation-text.status-regular { color: #856404; background-color: rgba(250, 204, 21, 0.15); }
        body.dark-mode .reputation-text.status-regular { color: var(--accent-yellow); background-color: rgba(253, 224, 71, 0.1); }
        .reputation-text.status-bad { color: var(--danger-color); background-color: rgba(220, 53, 69, 0.1); }
        .reputation-info { font-size: 0.8em; color: var(--text-secondary); margin-top: 15px; text-align: center; }


        .section-title { font-size: 1.3em; font-weight: 600; margin-bottom: 20px; border-bottom: 2px solid var(--accent-purple); padding-bottom: 10px; }
        .payment-history-list { display: flex; flex-direction: column; gap: 10px; }
        .payment-history-item { display: flex; justify-content: space-between; align-items: flex-start; background-color: var(--surface); border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; }
        .payment-info { flex-grow: 1; margin-right: 10px; }
        .payment-title { font-weight: 600; margin: 0 0 5px; font-size: 1em; }
        .payment-description { font-size: 0.9em; color: var(--text-secondary); margin: 0 0 8px; line-height: 1.4; }
        .payment-date { color: var(--text-secondary); font-size: 0.8em; }
        .payment-amount { font-weight: 600; }
        .payment-status-wrapper { display: flex; flex-direction: column; align-items: flex-end; gap: 4px; flex-shrink: 0; text-align: right; }
        .payment-status-tag { font-size: 0.75em; font-weight: 500; padding: 3px 8px; border-radius: 10px; }
        .payment-status-tag.pending { background-color: rgba(250, 204, 21, 0.15); color: #856404; }
        .payment-status-tag.approved { background-color: rgba(40, 167, 69, 0.1); color: var(--accent-green); }
        body.dark-mode .payment-status-tag.pending { background-color: rgba(253, 224, 71, 0.1); color: var(--accent-yellow); }
        body.dark-mode .payment-status-tag.approved { background-color: rgba(40, 167, 69, 0.2); }
        .no-history { color: var(--text-secondary); text-align: center; padding: 20px; }

        .loan-tabs-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            overflow-x: auto;
            padding-bottom: 5px; /* For the scroll bar */
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        .loan-tabs-container::-webkit-scrollbar { display: none; } /* Chrome, Safari, Opera */
        .loan-tab {
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--surface);
            color: var(--text-secondary);
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s ease-in-out;
        }
        .loan-tab.active {
            background-color: var(--accent-purple);
            color: white;
            border-color: var(--accent-purple);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(111, 66, 193, 0.3);
        }

        .bottom-nav { position: static; flex-shrink: 0; background-color: var(--surface); border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; padding: 10px 0; padding-bottom: calc(10px + env(safe-area-inset-bottom)); box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.05); transition: background-color 0.3s, border-color 0.3s; z-index: 150; }
        body.dark-mode .bottom-nav { box-shadow: none; }
        .nav-item { display: flex; flex-direction: column; align-items: center; gap: 5px; color: var(--text-secondary); text-decoration: none; font-size: 0.8em; padding: 5px 15px; cursor: pointer; }
        .nav-item.active { color: var(--accent-purple); }
        .nav-item.disabled { opacity: 0.5; cursor: not-allowed; }
        
        .view { display: none; }
        .view.active { display: block; }

        .profile-pic-wrapper { position: relative; cursor: pointer; }
        .profile-pic-wrapper::after { content: '✎'; position: absolute; bottom: 5px; right: 5px; background-color: rgba(0,0,0,0.6); color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 14px; }
        .profile-pic-wrapper img.loading { opacity: 0.5; }
        #profile-view-img { width: 100px; height: 100px; border-radius: 50%; border: 3px solid var(--accent-purple); object-fit: cover; }
        
        .settings-item { display: flex; align-items: center; gap: 15px; background-color: var(--surface); border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; cursor: pointer; font-weight: 500; text-decoration: none; color: var(--text-primary); }
        .settings-item.logout { color: var(--danger-color); }
        .settings-item.logout i { color: var(--danger-color); }

        .modal-view { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg); z-index: 200; transform: translateX(100%); transition: transform 0.3s ease-in-out; display: flex; flex-direction: column; }
        .modal-view.active { transform: translateX(0); }
        .modal-header { display: flex; align-items: center; padding: 15px 20px; background-color: var(--surface); border-bottom: 1px solid var(--border-color); position: sticky; top: 0; z-index: 210; flex-shrink: 0; }
        .modal-header button { background: none; border: none; color: var(--text-primary); cursor: pointer; padding: 0; margin-right: 15px; }
        .modal-title { font-size: 1.2em; font-weight: 600; }
        .modal-content-wrapper { flex-grow: 1; overflow-y: auto; }
        .action-buttons { background-color: var(--surface); border-top: 1px solid var(--border-color); padding: 15px 20px; padding-bottom: calc(15px + env(safe-area-inset-bottom)); display: flex; gap: 15px; margin-top: auto; position: sticky; bottom: 0; flex-shrink: 0; }
        .action-buttons button { flex-grow: 1; padding: 15px; font-size: 1em; font-weight: 600; border: none; border-radius: 8px; cursor: pointer; display: flex; justify-content: center; align-items: center; gap: 8px; }
        
        .btn-primary {
            background-color: var(--accent-purple);
            color: white;
            padding: 15px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-secondary { background-color: var(--bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-size: 0.9em; font-weight: 500; color: var(--text-secondary); }
        .form-group input { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); background-color: var(--surface); color: var(--text-primary); }

        #cropper-container { height: calc(100% - 150px); }
        #cropper-container img { max-width: 100%; height: auto; }
        
        #toast-container { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .toast { background-color: #333; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 0.9em; opacity: 0; transform: translateY(-20px); transition: opacity 0.3s, transform 0.3s; }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.toast-error { background-color: var(--danger-color); }

        #pix-qr-code { max-width: 200px; margin: 10px auto; display: block; border-radius: 8px; }
        #pix-copy-paste-code { width: 100%; padding: 10px; border-radius: 8px; background-color: var(--border-color); border: none; font-family: monospace; font-size: 0.9em; resize: none; }
        .upload-receipt-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; border: 2px dashed var(--border-color); padding: 20px; border-radius: 12px; cursor: pointer; text-align: center; }
        #receipt-preview { max-width: 100px; max-height: 100px; margin-top: 10px; border-radius: 8px; }
        
        .notification-badge { 
            position: absolute; top: 12px; right: 12px; width: 10px; height: 10px; background-color: var(--danger-color); border-radius: 50%; border: 2px solid var(--surface); 
        }
        .bottom-nav .nav-item { position: relative; }
        .bottom-nav .notification-badge { top: 3px; right: 10px; }
        
        .notifications-list { display: flex; flex-direction: column; gap: 10px; }
        .notification-item { display: flex; gap: 15px; background-color: var(--surface); border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; border-left: 4px solid var(--accent-purple); cursor: pointer; }
        .notification-item.unread { background-color: color-mix(in srgb, var(--accent-purple) 8%, var(--surface)); }
        .notification-icon { color: var(--accent-purple); flex-shrink: 0; margin-top: 3px; }
        .notification-content { flex-grow: 1; }
        .notification-title { font-weight: 600; margin: 0 0 5px; }
        .notification-body { font-size: 0.9em; color: var(--text-secondary); margin: 0; line-height: 1.5; }
        .notification-date { font-size: 0.8em; color: var(--text-secondary); margin-top: 8px; text-align: right; }
        .no-notifications { color: var(--text-secondary); text-align: center; padding: 20px; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="install-banner" style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: calc(100% - 40px); max-width: 380px; background-color: var(--surface); color: var(--text-primary); padding: 25px; border-radius: 16px; z-index: 5000; box-shadow: 0 10px 40px rgba(0,0,0,0.2); border: 1px solid var(--border-color); text-align: center;">

    <button id="close-install-banner" style="position: absolute; top: 15px; right: 15px; background: transparent; border: none; color: var(--text-secondary); font-size: 28px; cursor: pointer; line-height: 1; padding: 0;">&times;</button>

    <img src="https://res.cloudinary.com/dc6as14p0/image/upload/v1759873183/LOGO_LUMIX_REDUCI_czkw4p.png" alt="App Icon" style="width: 64px; height: 64px; margin-bottom: 15px;">

    <h3 style="margin: 0 0 8px; font-size: 1.2em; font-weight: 600;" data-lang-key="installAppTitle">Instale nosso aplicativo</h3>

    <p style="margin: 0 0 25px; font-size: 0.9em; color: var(--text-secondary); line-height: 1.5;" data-lang-key="installAppMsg">Uma experiência mais rápida e completa.</p>

    <button id="install-btn" style="background-color: var(--accent-purple); color: white; border: none; padding: 14px; border-radius: 10px; font-weight: 600; cursor: pointer; width: 100%; font-size: 1em;" data-lang-key="installBtn">Instalar</button>

</div>

    <div id="splash-screen">
        <img id="splash-logo" src="https://res.cloudinary.com/dc6as14p0/image/upload/v1759611967/LOGO---LUMIX-FINANZAS-REDUCIDO_gc8zow.png" alt="Logo">
    </div>

    <div id="login-view">
        <div class="login-card">
            <div class="logo">
                <img id="login-logo" src="https://res.cloudinary.com/dc6as14p0/image/upload/v1759611967/LOGO---LUMIX-FINANZAS-REDUCIDO_gc8zow.png" alt="Logo">
            </div>
            <h2 data-lang-key="welcome"></h2>
            <p data-lang-key="welcomeMsg"></p>
            <form id="login-form">
                <div class="form-group">
                    <label for="username" data-lang-key="username"></label>
                    <input type="text" id="username" required>
                </div>
                <div class="form-group">
                    <label for="password" data-lang-key="password"></label>
                    <input type="password" id="password" required>
                </div>
                <button type="submit" class="btn-primary" data-lang-key="loginBtn"></button>
            </form>
        </div>
    </div>

    <div id="app-container">
        <header class="main-header">
            <div class="logo">
                <img id="header-logo" src="https://res.cloudinary.com/dc6as14p0/image/upload/v1759611967/LOGO---LUMIX-FINANZAS-REDUCIDO_gc8zow.png" alt="Logo da Empresa">
                <span class="logo-text" data-lang-key="appTitle"></span>
            </div>
            <div class="header-controls">
                <div style="position: relative;">
                    <button class="header-btn" id="lang-toggle"><i data-lucide="globe"></i></button>
                    <div class="lang-dropdown" id="lang-dropdown" style="display: none;"><button data-lang="pt">Português</button><button data-lang="es">Español</button><button data-lang="en">English</button></div>
                </div>
                <button class="header-btn" id="theme-toggle"><i data-lucide="moon"></i></button>
                <div class="profile" id="header-profile-link" style="cursor: pointer;">
                    <img id="header-profile-img" src="" alt="Foto do Cliente">
                </div>
            </div>
        </header>
        <main>
            <div id="home-view" class="view active container">
                <div id="loan-tabs-container" class="loan-tabs-container"></div>
                <div class="kpi-card progress-card" style="margin-bottom: 20px;">
                    <h3 class="kpi-title" style="justify-content: center;" data-lang-key="loanProgress"></h3>
                    <div class="progress-circle">
                        <svg><circle class="bg-circle" cx="60" cy="60" r="54"></circle><circle id="progress-bar" class="progress-bar" cx="60" cy="60" r="54" style="stroke-dasharray: 339.292;"></circle></svg>
                        <div class="progress-text" id="progress-text"></div>
                    </div>
                </div>
                
                <div id="reputation-card" class="kpi-card reputation-card">
                   <h3 class="kpi-title" data-lang-key="reputationScore"></h3>
                   <div class="reputation-bar-container">
                       <div id="reputation-bar" class="reputation-bar"></div>
                   </div>
                   <div class="reputation-status">
                       <span id="reputation-value" class="reputation-value"></span>
                       <span id="reputation-text" class="reputation-text"></span>
                   </div>
                   <p class="reputation-info" data-lang-key="reputationInfo"></p>
                </div>

                <div class="kpi-grid" style="margin-top: 20px;">
                    <div class="kpi-card"><h3 class="kpi-title"><i data-lucide="coins"></i><span data-lang-key="totalValue"></span></h3><p class="kpi-value" id="total-value"></p></div>
                    <div class="kpi-card"><h3 class="kpi-title"><i data-lucide="dollar-sign"></i><span data-lang-key="remainingValue"></span></h3><p class="kpi-value purple" id="remaining-value"></p></div>
                     <div class="kpi-card"><h3 class="kpi-title"><i data-lucide="receipt"></i><span data-lang-key="installmentValue"></span></h3><p class="kpi-value purple" id="kpi-installment-value"></p></div>
                </div>
                <section><h2 class="section-title" data-lang-key="paymentHistory"></h2><div id="payment-history-list" class="payment-history-list"></div></section>
            </div>
            <div id="pay-view" class="view container">
                <h2 class="section-title" data-lang-key="payInstallment"></h2>
                <div class="kpi-card" style="margin-bottom: 20px;">
                    <h3 class="kpi-title" data-lang-key="qrCodePayment"></h3>
                    <img id="pix-qr-code" src="https://placehold.co/200x200/eee/ccc?text=Loading..." alt="PIX QR Code">
                    <textarea id="pix-copy-paste-code" rows="3" readonly></textarea>
                    <button class="btn-primary" id="copy-pix-code-btn" style="width:100%; margin-top:10px;"><i data-lucide="copy"></i> <span data-lang-key="copyCode"></span></button>
                </div>
                <div class="kpi-card" style="margin-bottom: 20px;">
                     <h3 class="kpi-title" data-lang-key="manualPayment"></h3>
                     <p data-lang-key="manualPixKey"></p>
                     <div style="display:flex; gap:10px; align-items:center;">
                         <strong id="manual-pix-key-value" style="background-color: var(--border-color); padding: 10px; border-radius: 8px; flex-grow:1; text-align: center;"></strong>
                         <button class="btn-primary" id="copy-manual-key-btn" style="flex-shrink:0;"><i data-lucide="copy"></i></button>
                     </div>
                </div>
                 <div class="kpi-card">
                    <h3 class="kpi-title" data-lang-key="uploadReceipt"></h3>
                    <div class="form-group">
                        <label for="receipt-amount" data-lang-key="paymentAmountLabel"></label>
                        <input type="number" id="receipt-amount" step="0.01" placeholder="0.00" class="form-control">
                    </div>
                     <label for="receipt-file-input" class="upload-receipt-btn">
                         <i data-lucide="upload-cloud"></i>
                         <span id="upload-label-text">Clique para anexar</span>
                         <img id="receipt-preview" style="display:none;">
                     </label>
                     <input type="file" id="receipt-file-input" accept="image/*" style="display:none;">
                     <button class="btn-primary" id="submit-receipt-btn" style="width:100%; margin-top:15px;" disabled><i data-lucide="send"></i> <span data-lang-key="submitForVerification"></span></button>
                 </div>
            </div>
            <div id="refinance-view" class="view container"></div>
            <div id="notifications-view" class="view container">
                <div class="section-title" style="display: flex; justify-content: space-between; align-items: center;">
                    <span data-lang-key="notificationsTitle"></span>
                    <button id="clear-notifications-btn" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; font-size: 0.8em; font-weight: 500; display:flex; align-items:center; gap: 4px;">
                        <i data-lucide="trash-2" style="width:14px; height:14px;"></i>
                        <span data-lang-key="clearNotifications"></span>
                    </button>
                </div>
                <div id="notifications-list" class="notifications-list"></div>
            </div>
            <div id="profile-view" class="view container">
                <div style="display: flex; flex-direction: column; align-items: center; margin-bottom: 30px;">
                   <label for="profile-pic-input" class="profile-pic-wrapper">
                       <img id="profile-view-img" src="" alt="Foto do Cliente">
                   </label>
                   <input type="file" id="profile-pic-input" accept="image/*" style="display: none;">
                   <h2 id="profile-view-name" style="margin: 15px 0 0; font-size: 1.5em;"></h2>
                </div>
                <section>
                   <h2 class="section-title" data-lang-key="settings"></h2>
                   <div style="display: flex; flex-direction: column; gap: 15px;">
                       <a class="settings-item" id="test-push-btn" style="color: var(--accent-orange);"><i data-lucide="send"></i><span>Test Push Notification</span></a>
                       <a class="settings-item logout" id="logout-btn"><i data-lucide="log-out"></i><span data-lang-key="logout"></span></a>
                   </div>
                </section>
            </div>
        </main>
        <nav class="bottom-nav">
            <a class="nav-item active" data-view="home"><i data-lucide="layout-dashboard"></i><span data-lang-key="navDashboard"></span></a>
            <a class="nav-item" data-view="pay"><i data-lucide="dollar-sign"></i><span data-lang-key="navPay"></span></a>
            <a class="nav-item" data-view="refinance"><i data-lucide="trending-up"></i><span data-lang-key="navRefinance"></span></a>
            <a class="nav-item" data-view="notifications"><i data-lucide="bell"></i><span data-lang-key="navNotifications"></span><span class="notification-badge" style="display: none;"></span></a>
        </nav>
    </div>

    <div id="cropperModal" class="modal-view"></div>
    <div id="toast-container"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, collection, collectionGroup, query, where, getDocs, doc, onSnapshot, updateDoc, arrayUnion, serverTimestamp, addDoc, getDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js"; // <-- Adicionado collectionGroup aqui
        import { getMessaging, getToken, onMessage } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-messaging.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-storage.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyBRxJjpH6PBi-GRxOXS8klv-8v91sO4X-Y",
            authDomain: "lumix-financas-app.firebaseapp.com",
            projectId: "lumix-financas-app",
            storageBucket: "lumix-financas-app.firebasestorage.app",
            messagingSenderId: "463777495321",
            appId: "1:463777495321:web:106118f53f56abd206ed88"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const storage = getStorage(app);

        
        const DEFAULT_LOGO_URL = "https://res.cloudinary.com/dc6as14p0/image/upload/v1759611967/LOGO---LUMIX-FINANZAS-REDUCIDO_gc8zow.png";
        
        let currentClient = null;
        let unsubscribeClient = null;
        let unsubscribeCollector = null;

        let currentAuthUid = null;     // ID do usuário logado no Firebase Auth
        let currentClientId = null;    // ID do documento do cliente no Firestore (ex: abc123xyz)
        let currentCompanyId = null;   // ID da empresa à qual o cliente pertence
        let currentCollectorId = null; // ID (username) do cobrador associado
        let currentCompanyData = null; // Dados da empresa (logo, nome, status) - Tarefa CL2

        let currentLang = localStorage.getItem('language') || 'pt';
        let deferredPrompt; // For PWA installation
        const nationalHolidays = [ '01/01', '21/04', '01/05', '07/09', '12/10', '02/11', '15/11', '25/12' ];
        let receiptFile = null;
        let notificationInterval;
        let selectedLoanIndex = 0;
        let collectorSettings = null; // Para almacenar la configuración del cobrador

        const PAYMENT_CONFIGS = {
            // Suramérica
            "BRL": { name: "Real Brasileiro", methods: [ { id: 'brl_pix', label: 'Chave PIX', type: 'text', placeholder: 'CPF, e-mail, telefone...' }, { id: 'brl_qrcode_text', label: 'PIX Copia e Cola', type: 'textarea', placeholder: 'Cole o código BR...' }, { id: 'brl_qrcode_image', label: 'Imagem QR Code PIX', type: 'image' } ]},
            "ARS": { name: "Peso Argentino", methods: [ { id: 'ars_mercadopago', label: 'Mercado Pago (CVU/Alias)', type: 'text', placeholder: 'CVU ou Alias da conta' }, { id: 'ars_transferencia', label: 'Transferencia Bancaria (CBU)', type: 'text', placeholder: 'CBU da conta bancária' } ]},
            "BOB": { name: "Boliviano", methods: [ { id: 'bob_qr', label: 'QR Simple', type: 'image' }, { id: 'bob_tigomoney', label: 'Tigo Money', type: 'tel', placeholder: 'Número de Teléfono' } ]},
            "CLP": { name: "Peso Chileno", methods: [ { id: 'clp_transferencia', label: 'Transferencia (Cuenta RUT)', type: 'text', placeholder: 'RUT o datos de la cuenta' } ]},
            "COP": { name: "Peso Colombiano", methods: [ { id: 'cop_nequi', label: 'Nequi', type: 'tel', placeholder: 'Número de telefone Nequi' }, { id: 'cop_daviplata', label: 'Daviplata', type: 'tel', placeholder: 'Número de telefone Daviplata' }, { id: 'cop_bancolombia', label: 'Bancolombia A la Mano', type: 'text', placeholder: 'Número de cuenta o teléfono' }, { id: 'cop_qrcode_image', label: 'Imagem QR Code Genérico', type: 'image' } ]},
            "USD_EC": { name: "Dólar (Ecuador)", methods: [ { id: 'ec_transferencia_pichincha', label: 'Transferencia Banco Pichincha', type: 'text', placeholder: 'Datos de la cuenta' }, { id: 'ec_transferencia_guayaquil', label: 'Transferencia Banco Guayaquil', type: 'text', placeholder: 'Datos de la cuenta' } ]},
            "PYG": { name: "Guaraní Paraguayo", methods: [ { id: 'pyg_giros', label: 'Giros Tigo / Personal', type: 'tel', placeholder: 'Número de Teléfono' }, { id: 'pyg_transferencia', label: 'Transferencia Bancaria', type: 'text', placeholder: 'Datos de la cuenta' } ]},
            "PEN": { name: "Sol Peruano", methods: [ { id: 'pen_yape', label: 'Yape', type: 'tel', placeholder: 'Número de Celular o QR' }, { id: 'pen_plin', label: 'Plin', type: 'tel', placeholder: 'Número de Celular' } ]},
            "UYU": { name: "Peso Uruguayo", methods: [ { id: 'uyu_transferencia', label: 'Transferencia Bancaria', type: 'text', placeholder: 'Datos de la cuenta' } ]},
            "VES": { name: "Bolívar Venezuelano", methods: [ { id: 'ves_pagomovil', label: 'Pago Móvil', type: 'text', placeholder: 'C.I, Banco, Teléfono' } ]},
            // Centroamérica
            "CRC": { name: "Colón Costarricense", methods: [ { id: 'crc_sinpe', label: 'SINPE Móvil', type: 'tel', placeholder: 'Número de Teléfono' } ]},
            "GTQ": { name: "Quetzal Guatemalteco", methods: [ { id: 'gtq_transferencia', label: 'Transferencia Bancaria', type: 'text', placeholder: 'Datos de la cuenta (BAC, BI, etc.)' } ]},
            "HNL": { name: "Lempira Hondureña", methods: [ { id: 'hnl_tigomoney', label: 'Tigo Money', type: 'tel', placeholder: 'Número de Teléfono' }, { id: 'hnl_transferencia', label: 'Transferencia Bancaria', type: 'text', placeholder: 'Datos de la cuenta' } ]},
            "NIO": { name: "Córdoba Nicaragüense", methods: [ { id: 'nio_transferencia', label: 'Transferencia Bancaria', type: 'text', placeholder: 'Datos de la cuenta (Lafise, BAC)' } ]},
            "PAB": { name: "Balboa Panameño / USD", methods: [ { id: 'pab_yappy', label: 'Yappy (Banco General)', type: 'tel', placeholder: 'Número de Teléfono' }, { id: 'pab_nequi', label: 'Nequi Panamá', type: 'tel', placeholder: 'Número de Teléfono' } ]},
            "USD_SV": { name: "Dólar (El Salvador)", methods: [ { id: 'sv_chivo', label: 'Chivo Wallet', type: 'text', placeholder: 'Número de DUI o Teléfono' }, { id: 'sv_transferencia', label: 'Transferencia Bancaria', type: 'text', placeholder: 'Datos de la cuenta' } ]},
            // Norteamérica y General
            "USD": { name: "Dólar Americano (General)", methods: [ { id: 'usd_zelle', label: 'Zelle', type: 'email', placeholder: 'E-mail ou telefone Zelle' }, { id: 'usd_cashapp', label: 'Cash App', type: 'text', placeholder: '$Cashtag' }, { id: 'usd_paypal', label: 'PayPal', type: 'email', placeholder: 'E-mail do PayPal.me' } ]},
            "MXN": { name: "Peso Mexicano", methods: [ { id: 'mxn_spei', label: 'Transferencia SPEI (CLABE)', type: 'text', placeholder: 'CLABE Interbancaria' }, { id: 'mxn_oxxo', label: 'Pago en OXXO', type: 'text', placeholder: 'Número de referência para OXXO Pay' } ]},
            "CAD": { name: "Dólar Canadiense", methods: [ { id: 'cad_interac', label: 'Interac e-Transfer', type: 'email', placeholder: 'Email para transferencia' } ]}
        };

        const CURRENCY_FORMATS = {
            "BRL": { locale: 'pt-BR', currency: 'BRL' }, "ARS": { locale: 'es-AR', currency: 'ARS' },
            "BOB": { locale: 'es-BO', currency: 'BOB' }, "CLP": { locale: 'es-CL', currency: 'CLP' },
            "COP": { locale: 'es-CO', currency: 'COP' }, "USD_EC": { locale: 'es-EC', currency: 'USD' },
            "PYG": { locale: 'es-PY', currency: 'PYG' }, "PEN": { locale: 'es-PE', currency: 'PEN' },
            "UYU": { locale: 'es-UY', currency: 'UYU' }, "VES": { locale: 'es-VE', currency: 'VES' },
            "CRC": { locale: 'es-CR', currency: 'CRC' }, "GTQ": { locale: 'es-GT', currency: 'GTQ' },
            "HNL": { locale: 'es-HN', currency: 'HNL' }, "NIO": { locale: 'es-NI', currency: 'NIO' },
            "PAB": { locale: 'es-PA', currency: 'PAB' }, "USD_SV": { locale: 'es-SV', currency: 'USD' },
            "USD": { locale: 'en-US', currency: 'USD' }, "MXN": { locale: 'es-MX', currency: 'MXN' },
            "CAD": { locale: 'en-CA', currency: 'CAD' }
        };
        
        const PIX_KEY_FIXED = "000.0.0.000-00"; // This is now legacy, will be replaced by dynamic data.
        const PIX_KEY_MANUAL = "chave-manual@email.com"; // This is now legacy.

        // ¡¡¡ ACCIÓN REQUERIDA !!!
        // Reemplaza la siguiente clave con tu "Public VAPID key" real desde:
        // Firebase Console -> Project Settings -> Cloud Messaging -> Web configuration -> Key pair
        const FCM_VAPID_KEY = "BAgKWBzKi_Z4eyNNgGtprgPRQhPzU2MqU1vyrHf0iQSMxy1UMkin4E3GJ7KQLtChcDJHtEx8mMYau4jtzQvtjfw"; // IMPORTANTE: Substitua pela sua VAPID key do Firebase Cloud Messaging

        const translations = {
            pt: {
                welcome: 'Bem-vindo de volta',
                welcomeMsg: 'Acesse sua conta para continuar',
                username: 'Nome de usuário',
                password: 'Senha',
                loginBtn: 'Entrar',
                invalidCredentials: 'Usuário ou senha inválidos.',
                genericError: 'Ocorreu um erro. Tente novamente.',
                appTitle: 'Portal do Cliente',
                loanProgress: 'Progresso do Empréstimo',
                reputationScore: 'Pontuação de Reputação',
                reputationInfo: 'Pagar em dia melhora sua pontuação.',
                totalValue: 'Valor Total',
                remainingValue: 'Valor Restante',
                installmentValue: 'Valor da Parcela',
                paymentHistory: 'Histórico de Pagamentos',
                noPayments: 'Nenhum pagamento registrado.',
                reputationPerfect: 'Perfeito',
                reputationGood: 'Bom',
                reputationRegular: 'Regular',
                reputationBad: 'Ruim',
                payInstallment: 'Pagar Parcela',
                qrCodePayment: 'Pagar com QR Code',
                manualPayment: 'Pagar com Chave Manual',
                manualPixKey: 'Use esta chave PIX para pagamento manual:',
                copyCode: 'Copiar Código',
                copied: 'Código PIX copiado!',
                uploadReceipt: 'Enviar Comprovante',
                paymentAmountLabel: 'Valor do Pagamento',
                submitForVerification: 'Enviar para Verificação',
                receiptSent: 'Comprovante enviado para análise!',
                uploadError: 'Erro ao enviar comprovante.',
                invalidAmount: 'Por favor, insira um valor válido.',
                paymentSent: 'enviou um comprovante de pagamento no valor de',
                settings: 'Configurações',
                logout: 'Sair',
                accountNotFound: 'Conta não encontrada. Faça login novamente.',
                dataLoadError: 'Erro ao carregar dados.',
                cropImage: 'Recortar Imagem',
                cancel: 'Cancelar',
                confirmCrop: 'Confirmar',
                picUpdateSuccess: 'Foto de perfil atualizada!',
                picUpdateError: 'Erro ao atualizar foto.',
                navDashboard: 'Painel',
                navPay: 'Pagar',
                navRefinance: 'Refinanciar',
                navNotifications: 'Notificações',
                notificationsTitle: 'Notificações',
                clearNotifications: 'Limpar tudo',
                notificationsCleared: 'Notificações limpas.',
                notificationRead: 'Notificação marcada como lida.',
                noNotifications: 'Nenhuma notificação nova.',
                awaitingVerification: 'Aguardando verificação',
                approved: 'Aprovado',
                installAppTitle: 'Instale nosso aplicativo',
                installAppMsg: 'Uma experiência mais rápida e completa.',
                installBtn: 'Instalar',
                refinanceTitle: 'Refinanciamento',
                requestNewFinancing: 'Solicitar Novo Financiamento',
                newAmount: 'Novo Valor Desejado',
                newInstallments: 'Número de Parcelas',
                sendForAnalysis: 'Enviar para Análise',
                analysisSent: 'Solicitação enviada para análise, aguarde o contato do seu cobrador!',
                refinanceRequested: 'solicitou um refinanciamento de',
                reputationNotGoodTitle: 'Melhore sua Pontuação',
                reputationNotGoodMsg: 'Para solicitar um refinanciamento, sua pontuação de reputação precisa ser "Perfeita". Continue pagando suas parcelas em dia!',
                latePaymentReminderTitle: 'Lembrete de Pagamento',
                latePaymentReminderBody: 'Notamos um atraso em seu pagamento. Para evitar encargos, por favor, regularize sua situação.',
                urgentWarningTitle: 'AVISO URGENTE: Pagamentos Atrasados',
                urgentWarningBody: 'Você possui {count} parcelas em atraso. É crucial que você regularize sua dívida.',
                paymentInstallmentTitle: 'Pagamento Parcela #{installment}',
                paymentInstallmentsTitle: 'Pagamento Parcelas #{start} - #{end}',
                partialPaymentDesc: 'Pagamento parcial ({percent}%) da parcela.',
                fullPaymentDesc: 'Parcela #{installment} paga integralmente.',
                multiplePaymentDesc: 'Cobre {count} parcela(s) e {percent}% da próxima.',
                multipleFullPaymentDesc: 'Cobre {count} parcela(s) integralmente.',
                loanFinished: 'Seu empréstimo já foi totalmente pago!',
                loanLabel: 'Empréstimo',
                paymentOptions: 'Opções de Pagamento',
                copyKey: 'Copiar Chave',
                noPaymentMethodsConfigured: 'Nenhum método de pagamento configurado pelo seu cobrador.'
            },
            es: {
                welcome: 'Bienvenido de vuelta',
                welcomeMsg: 'Accede a tu cuenta para continuar',
                username: 'Nombre de usuario',
                password: 'Contraseña',
                loginBtn: 'Entrar',
                invalidCredentials: 'Usuario o contraseña inválidos.',
                genericError: 'Ocurrió un error. Inténtalo de nuevo.',
                appTitle: 'Portal del Cliente',
                loanProgress: 'Progreso del Préstamo',
                reputationScore: 'Puntuación de Reputación',
                reputationInfo: 'Pagar a tiempo mejora tu puntuación.',
                totalValue: 'Valor Total',
                remainingValue: 'Valor Restante',
                installmentValue: 'Valor de la Cuota',
                paymentHistory: 'Historial de Pagos',
                noPayments: 'No hay pagos registrados.',
                reputationPerfect: 'Perfecto',
                reputationGood: 'Bueno',
                reputationRegular: 'Regular',
                reputationBad: 'Malo',
                payInstallment: 'Pagar Cuota',
                qrCodePayment: 'Pagar con Código QR',
                manualPayment: 'Pagar con Clave Manual',
                manualPixKey: 'Usa esta clave PIX para pago manual:',
                copyCode: 'Copiar Código',
                copied: '¡Código PIX copiado!',
                uploadReceipt: 'Enviar Comprobante',
                paymentAmountLabel: 'Valor del Pago',
                submitForVerification: 'Enviar para Verificación',
                receiptSent: '¡Comprobante enviado para análisis!',
                uploadError: 'Error al enviar el comprobante.',
                invalidAmount: 'Por favor, ingrese un valor válido.',
                paymentSent: 'envió un comprobante de pago por valor de',
                settings: 'Configuración',
                logout: 'Salir',
                accountNotFound: 'Cuenta no encontrada. Inicia sesión de nuevo.',
                dataLoadError: 'Error al cargar los datos.',
                cropImage: 'Recortar Imagen',
                cancel: 'Cancelar',
                confirmCrop: 'Confirmar',
                picUpdateSuccess: '¡Foto de perfil actualizada!',
                picUpdateError: 'Error al actualizar la foto.',
                navDashboard: 'Panel',
                navPay: 'Pagar',
                navRefinance: 'Refinanciar',
                navNotifications: 'Notificaciones',
                notificationsTitle: 'Notificaciones',
                clearNotifications: 'Limpiar todo',
                notificationsCleared: 'Notificações limpiadas.',
                notificationRead: 'Notificación marcada como leída.',
                noNotifications: 'No hay notificaciones nuevas.',
                awaitingVerification: 'Esperando verificación',
                approved: 'Aprobado',
                installAppTitle: 'Instala nuestra aplicación',
                installAppMsg: 'Una experiencia más rápida y completa.',
                installBtn: 'Instalar',
                refinanceTitle: 'Refinanciación',
                requestNewFinancing: 'Solicitar Nueva Financiación',
                newAmount: 'Nuevo Valor Deseado',
                newInstallments: 'Número de Cuotas',
                sendForAnalysis: 'Enviar para Análisis',
                analysisSent: '¡Solicitud enviada para análisis!',
                refinanceRequested: 'solicitó una refinanciación de',
                reputationNotGoodTitle: 'Mejora tu Puntuación',
                reputationNotGoodMsg: 'Para solicitar una refinanciación, tu puntuación de reputación debe ser "Perfecta". ¡Sigue pagando tus cuotas a tiempo!',
                latePaymentReminderTitle: 'Recordatorio de Pago',
                latePaymentReminderBody: 'Hemos notado un retraso en su pago. Para evitar cargos, por favor, regularice su situación.',
                urgentWarningTitle: 'AVISO URGENTE: Pagos Atrasados',
                urgentWarningBody: 'Usted tiene {count} cuotas atrasadas. Es crucial que regularice su deuda.',
                paymentInstallmentTitle: 'Pago Cuota #{installment}',
                paymentInstallmentsTitle: 'Pago Cuotas #{start} - #{end}',
                partialPaymentDesc: 'Pago parcial ({percent}%) de la cuota.',
                fullPaymentDesc: 'Cuota #{installment} pagada completamente.',
                multiplePaymentDesc: 'Cubre {count} cuota(s) y un {percent}% de la siguiente.',
                multipleFullPaymentDesc: 'Cubre {count} cuota(s) completamente.',
                loanFinished: '¡Tu préstamo ya ha sido pagado en su totalidad!',
                loanLabel: 'Préstamo',
                paymentOptions: 'Opciones de Pagamento',
                copyKey: 'Copiar Clave',
                noPaymentMethodsConfigured: 'Ningún método de pago configurado por tu cobrador.'
            },
            en: {
                welcome: 'Welcome back',
                welcomeMsg: 'Log in to your account to continue',
                username: 'Username',
                password: 'Password',
                loginBtn: 'Login',
                invalidCredentials: 'Invalid username or password.',
                genericError: 'An error occurred. Please try again.',
                appTitle: 'Client Portal',
                loanProgress: 'Loan Progress',
                reputationScore: 'Reputation Score',
                reputationInfo: 'Paying on time improves your score.',
                totalValue: 'Total Value',
                remainingValue: 'Remaining Value',
                installmentValue: 'Installment Value',
                paymentHistory: 'Payment History',
                noPayments: 'No payments registered.',
                reputationPerfect: 'Perfect',
                reputationGood: 'Good',
                reputationRegular: 'Regular',
                reputationBad: 'Bad',
                payInstallment: 'Pay Installment',
                qrCodePayment: 'Pay with QR Code',
                manualPayment: 'Pay with Manual Key',
                manualPixKey: 'Use this PIX key for manual payment:',
                copyCode: 'Copy Code',
                copied: 'PIX Code copied!',
                uploadReceipt: 'Upload Receipt',
                paymentAmountLabel: 'Payment Amount',
                submitForVerification: 'Submit for Verification',
                receiptSent: 'Receipt sent for analysis!',
                uploadError: 'Error uploading receipt.',
                invalidAmount: 'Please enter a valid amount.',
                paymentSent: 'sent a payment receipt for the amount of',
                settings: 'Settings',
                logout: 'Logout',
                accountNotFound: 'Account not found. Please log in again.',
                dataLoadError: 'Error loading data.',
                cropImage: 'Crop Image',
                cancel: 'Cancel',
                confirmCrop: 'Confirm',
                picUpdateSuccess: 'Profile picture updated!',
                picUpdateError: 'Error updating picture.',
                navDashboard: 'Dashboard',
                navPay: 'Pay',
                navRefinance: 'Refinance',
                navNotifications: 'Notifications',
                notificationsTitle: 'Notifications',
                clearNotifications: 'Clear all',
                notificationsCleared: 'Notifications cleared.',
                notificationRead: 'Notification marked as read.',
                noNotifications: 'No new notifications.',
                awaitingVerification: 'Awaiting verification',
                approved: 'Approved',
                installAppTitle: 'Install our app',
                installAppMsg: 'A faster and more complete experience.',
                installBtn: 'Install',
                refinanceTitle: 'Refinancing',
                requestNewFinancing: 'Request New Financing',
                newAmount: 'New Desired Amount',
                newInstallments: 'Number of Installments',
                sendForAnalysis: 'Send for Analysis',
                analysisSent: 'Request sent for analysis!',

                refinanceRequested: 'requested a refinancing of',
                reputationNotGoodTitle: 'Improve Your Score',
                reputationNotGoodMsg: 'To request refinancing, your reputation score needs to be "Perfect". Keep paying your installments on time!',
                latePaymentReminderTitle: 'Payment Reminder',
                latePaymentReminderBody: 'We noticed a delay in your payment. To avoid charges, please regularize your situation.',
                urgentWarningTitle: 'URGENT NOTICE: Overdue Payments',
                urgentWarningBody: 'You have {count} overdue installments. It is crucial that you regularize your debt.',
                paymentInstallmentTitle: 'Payment Installment #{installment}',
                paymentInstallmentsTitle: 'Payment Installments #{start} - #{end}',
                partialPaymentDesc: 'Partial payment ({percent}%) of the installment.',
                fullPaymentDesc: 'Installment #{installment} paid in full.',
                multiplePaymentDesc: 'Covers {count} installment(s) and {percent}% of the next one.',
                multipleFullPaymentDesc: 'Covers {count} installment(s) completely.',
                loanFinished: 'Your loan is already fully paid!',
                loanLabel: 'Loan',
                paymentOptions: 'Opciones de Pagamento',
                copyKey: 'Copiar Clave',
                noPaymentMethodsConfigured: 'No payment methods have been configured by your collector.'
            }
        };

        function showToast(message, isError = false) {
            const container = document.getElementById('toast-container');
            if (!container) return;
            const toast = document.createElement('div');
            toast.className = 'toast';
            if (isError) {
                toast.classList.add('toast-error');
            }
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    container.removeChild(toast);
                }, 300);
            }, 3000);
        }

        function showBlockedView(message) {
    console.error("Acceso bloqueado:", message);
    document.getElementById('splash-screen').style.display = 'none';
    document.getElementById('login-view').style.display = 'none';
    document.getElementById('app-container').style.display = 'none';

    let blockedView = document.getElementById('blocked-view');
    if (!blockedView) {
        blockedView = document.createElement('div');
        blockedView.id = 'blocked-view';
        blockedView.style.cssText = 'display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; padding: 20px; text-align: center; background-color: var(--bg);';
        document.body.appendChild(blockedView);
    }

    blockedView.innerHTML = `
        <i data-lucide="shield-off" style="width: 64px; height: 64px; color: var(--danger-color); margin-bottom: 20px;"></i>
        <h2 style="color: var(--text-primary); margin-bottom: 10px;">Acesso Negado</h2>
        <p style="color: var(--text-secondary); max-width: 400px; line-height: 1.5;">${message}</p>
        <button id="logout-blocked-btn" class="btn-primary" style="margin-top: 30px; background-color: var(--danger-color); border: none;">Sair (Log Out)</button>
    `;
    lucide.createIcons({ nodes: [blockedView.querySelector('i')] });

    const logoutBtn = document.getElementById('logout-blocked-btn');
    if (logoutBtn) {
        // Remover listener antigo para segurança
        logoutBtn.replaceWith(logoutBtn.cloneNode(true));
        document.getElementById('logout-blocked-btn').addEventListener('click', () => {
            signOut(auth).catch(err => console.error("Error en logout forzado:", err));
        });
    }
}

        function money(value) {
            const currencyCode = collectorSettings?.paymentSettings?.currency || 'BRL';
            const format = CURRENCY_FORMATS[currencyCode] || CURRENCY_FORMATS['BRL'];
            return (value || 0).toLocaleString(format.locale, { style: 'currency', currency: format.currency });
        }

        async function sendNotificationTicket(title, body, type, icon) {
            const LOG_PREFIX = `[CLIENTE-APP]`;
            console.log(`${LOG_PREFIX} -> Preparando ticket/notificación...`);
            
            // --- [CAMBIO CLAVE] ---
            // 1. Prepara el objeto de notificación interna, PERO NO LO GUARDA.
            // Usamos new Date() para que la hora sea consistente con la del timestamp del préstamo.
            const internalNotif = {
                title: title, 
                body: body, 
                icon: icon, 
                read: false, 
                timestamp: new Date(),
                id: `${type}_${Date.now()}`
            };

            try {
                // 2. Crea el ticket para la notificación PUSH (Esto se mantiene)
                // (La Cloud Function se encargará de procesar esto para el push)
                const ticketsCollectionRef = collection(db, 'companies', currentCompanyId, 'clients', currentClientId, 'pushNotificationTickets'); 
                await addDoc(ticketsCollectionRef, { 
                    title: title, body: body, type: type
                });
                console.log(`${LOG_PREFIX} -> sendNotificationTicket: ¡ÉXITO! Ticket PUSH creado en Firestore.`);

                // 3. DEVUELVE el objeto de notificación interna
                return internalNotif; 

            } catch (error) {
                console.error(`${LOG_PREFIX} -> sendNotificationTicket: ERROR FATAL al crear ticket PUSH.`, error);
                return null; // Devuelve null si falla la creación del ticket
            }
        }

        async function checkAndSendLatePaymentNotifications() {
            const LOG_PREFIX = `[CLIENTE-APP]`;
            if (!currentClient || !currentClient.loans || currentClient.loans.length === 0 || !currentCompanyId || !currentClientId) return;

            // console.log(`${LOG_PREFIX} -> checkAndSendLatePaymentNotifications: Iniciando verificación de atrasos para TODOS los préstamos...`);

            const now = new Date();
            const clientRef = doc(db, 'companies', currentCompanyId, 'clients', currentClientId);
            
            let updatesNeeded = false; // Flag para saber si necesitamos actualizar Firestore
            // Hacemos una copia profunda de los préstamos actuales para modificarla
            let updatedLoans = JSON.parse(JSON.stringify(currentClient.loans)); 
            let newInternalNotifications = []; // Acumulador para las nuevas notificaciones

            // Iterar por CADA préstamo que tenga el cliente
            for (let i = 0; i < updatedLoans.length; i++) {
                const loan = updatedLoans[i];
                
                // 1. Calcular el estado REAL del préstamo
                const details = calculateLoanDetails(loan); // Usamos la función robusta
                const lateInstallments = details.lateDays; // Obtenemos los días de atraso
                
                // Si no está 'late' (puede ser 'pending', 'paid', 'finished'), no hacemos nada
                if (details.status !== 'late') {
                    // console.log(`${LOG_PREFIX} -> Préstamo ${i + 1}: OK (Estado: ${details.status}).`);
                    continue; // Vamos al siguiente préstamo
                }

                // 2. El préstamo ESTÁ ATRASADO. Verificar cuándo fue la última notificación.
                console.log(`${LOG_PREFIX} -> Préstamo ${i + 1}: ¡ATRASADO! Días: ${lateInstallments}`);
                
                // [LÍNEA ORIGINAL CON ERROR]
                // const lastNotificationTimestamp = loan.lastLateNotificationTimestamp?.toDate(); 
                
                // --- [INICIO DE LA CORRECCIÓN] ---
                // 'loan.lastLateNotificationTimestamp' puede ser un string (de JSON.stringify)
                // o un Timestamp. Necesitamos un objeto Date de JS.
                let lastNotificationTimestamp = null;
                if (loan.lastLateNotificationTimestamp) {
                    if (typeof loan.lastLateNotificationTimestamp.toDate === 'function') {
                        // Caso 1: Es un Timestamp de Firestore (improbable aquí, pero seguro)
                        lastNotificationTimestamp = loan.lastLateNotificationTimestamp.toDate();
                    } else {
                        // Caso 2: Es un string ISO (el caso más probable) o un objeto Date.
                        // new Date() puede parsear ambos.
                        lastNotificationTimestamp = new Date(loan.lastLateNotificationTimestamp);
                    }
                }
                // --- [FIN DE LA CORRECCIÓN] ---
                
                // 3. Definir la frecuencia requerida
                let requiredIntervalHours;
                if (lateInstallments === 1) {
                    // 1 día de atraso: 1 vez al día (aprox 22 horas para dar margen)
                    requiredIntervalHours = 22; 
                } else {
                    // 2+ días de atraso: 2 veces al día (aprox 12 horas)
                    requiredIntervalHours = 12;
                }

                const hoursAgo = new Date(now.getTime() - (requiredIntervalHours * 60 * 60 * 1000));

                // 4. Decidir si enviar
                if (lastNotificationTimestamp && lastNotificationTimestamp > hoursAgo) {
                    console.log(`${LOG_PREFIX} -> Préstamo ${i + 1}: Notificación suprimida (enviada hace menos de ${requiredIntervalHours}h).`);
                    continue; // Ya se notificó, vamos al siguiente préstamo
                }

                // 5. Es necesario enviar. Preparar el mensaje.
                console.log(`${LOG_PREFIX} -> Préstamo ${i + 1}: Enviando notificación (Atraso: ${lateInstallments} días).`);
                
                let title, body, type, icon;
                // Identificador "Préstamo 1", "Préstamo 2", etc.
                const loanIdentifier = `${translations[currentLang].loanLabel} ${i + 1}`; 

                if (lateInstallments === 1) {
                    title = `${translations[currentLang].latePaymentReminderTitle} (${loanIdentifier})`;
                    body = translations[currentLang].latePaymentReminderBody;
                    type = 'late_reminder';
                    icon = 'alarm-clock';
                } else { 
                    // Mensaje creativo (como pediste)
                    title = `${translations[currentLang].urgentWarningTitle} (${loanIdentifier})`;
                    body = translations[currentLang].urgentWarningBody.replace('{count}', lateInstallments) + " " + translations[currentLang].reputationInfo; 
                    type = 'urgent_warning';
                    icon = 'alert-triangle';
                }

                // 6. CREAR el ticket PUSH y OBTENER el objeto de notificación interna
                const newNotifObject = await sendNotificationTicket(title, body, type, icon);

                if (newNotifObject) {
                    // 7. ACUMULAR la notificación interna
                    newInternalNotifications.push(newNotifObject);
                    // y ACTUALIZAR el timestamp del préstamo (en nuestra copia local)
                    loan.lastLateNotificationTimestamp = new Date(); 
                    updatesNeeded = true;
                }
            }

            // 8. Si hicimos algún cambio, actualizamos Firestore UNA VEZ.
            if (updatesNeeded) {
                console.log(`${LOG_PREFIX} -> Actualizando Firestore con ${newInternalNotifications.length} nuevas notificaciones y timestamps...`);
                
                // Obtenemos las notificaciones antiguas (de la copia de currentClient)
                const oldNotifications = currentClient.notifications || [];
                
                // Actualizamos el documento del cliente con los préstamos modificados Y las nuevas notificaciones
                await updateDoc(clientRef, { 
                    loans: updatedLoans, // El array de préstamos con los nuevos timestamps
                    notifications: [...oldNotifications, ...newInternalNotifications] // Añadimos las nuevas notificaciones
                }); 
                console.log(`${LOG_PREFIX} -> Firestore actualizado.`);
            } else {
                // console.log(`${LOG_PREFIX} -> Verificación de atrasos finalizada. Sin notificaciones nuevas para enviar.`);
            }
        }

        function applyLanguage(lang) {
            currentLang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (translations[lang] && translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });
            document.documentElement.lang = lang.startsWith('es') ? 'es' : (lang.startsWith('en') ? 'en' : 'pt-BR');
        }

        function applyTheme(theme) {
            const body = document.body;
            body.classList.toggle('dark-mode', theme === 'dark');
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                themeToggle.innerHTML = `<i data-lucide="${theme === 'dark' ? 'sun' : 'moon'}"></i>`;
                lucide.createIcons({ nodes: [themeToggle] });
            }
        }
        

        function calculateLoanDetails(loan) {
    let details = {
        lateDays: 0,
        lateFeesAccumulated: 0,
        status: 'pending', // Estado por defecto
        nextDueDate: null, // Fecha del próximo vencimiento
        amountDueToday: 0 // Cuánto debería pagar HOY si es día de pago
    };

    // --- INICIO CÁLCULO DEL TOTAL PAGADO DESDE HISTORIAL ---
    const currentTotalPaid = (loan.history || [])
        .filter(h => h.status !== 'pending_verification' && h.status !== 'rejected' && h.status !== 'postponed') // Solo pagos aprobados/válidos
        .reduce((sum, h) => sum + (h.amount || 0), 0);
    // --- FIN CÁLCULO ---

    // Si no hay préstamo o ya está finalizado, no hay nada que calcular.
    if (!loan || !loan.totalLoan || loan.status === 'finished' || (loan.paid >= loan.totalLoan)) {
        details.status = 'finished';
        return details;
    }

    const today = new Date(); 
    today.setHours(0, 0, 0, 0);

    // Determinar la fecha de inicio relevante (inicio del préstamo o último pago)
    let lastRelevantDate;
    if (loan.history && loan.history.length > 0) {
        const sortedHistory = [...loan.history]
            .filter(h => h.date?.seconds && h.status !== 'pending_verification' && h.status !== 'postponed') // Ignorar pendientes y aplazados
            .sort((a, b) => b.date.seconds - a.date.seconds);
        if (sortedHistory.length > 0) {
            lastRelevantDate = new Date(sortedHistory[0].date.seconds * 1000);
        }
    }
    if (!lastRelevantDate && loan.startDate?.seconds) {
        lastRelevantDate = new Date(loan.startDate.seconds * 1000);
    }

    if (!lastRelevantDate) {
        console.warn("No se puede calcular el estado: falta fecha de inicio o historial.");
        return details; // No podemos calcular sin una fecha base
    }
    lastRelevantDate.setHours(0, 0, 0, 0);

    // --- Lógica Principal de Cálculo ---
    let checkDate = new Date(lastRelevantDate);
    let accumulatedLateDays = 0;
    let accumulatedLateFees = 0;
    const dailyLateRate = (loan.lateFeeRate || 0) / 100; // Tasa diaria como decimal
    const installmentAmount = loan.originalInstallmentAmount || 0;
    let installmentsDueCount = 0; // Cuántas cuotas deberían haberse pagado hasta hoy
    let nextDueDateFound = false;

    // Bucle para calcular cuotas vencidas, días de atraso y mora
    while (checkDate <= today) {
        const dayOfWeek = checkDate.getDay();
        const dayOfMonth = checkDate.getDate();
        const formattedDate = `${String(checkDate.getDate()).padStart(2, '0')}/${String(checkDate.getMonth() + 1).padStart(2, '0')}`;
        const isHoliday = nationalHolidays.includes(formattedDate);
        const frequency = loan.paymentFrequency || 'daily';
        let isPaymentDay = false;

        if (frequency === 'daily') isPaymentDay = (loan.paymentDays || []).includes(dayOfWeek);
        else if (frequency === 'weekly') isPaymentDay = (loan.paymentDays || [])[0] === dayOfWeek;
        else if (frequency === 'monthly') isPaymentDay = (loan.paymentDays || [])[0] === dayOfMonth;

        // Es un día de pago válido (no feriado, no domingo si es diario/semanal)
        // [CORRECCIÓN] Domingo (0) SÍ cuenta como día de pago si está explícitamente seleccionado.
        // Solo se excluyen feriados.
        if (!isHoliday && isPaymentDay) {

            // Si la fecha es ANTERIOR a hoy, cuenta como cuota vencida
            if (checkDate < today) {
                installmentsDueCount++;

                // Calcular mora SOLO si la tasa es mayor a 0
                if (dailyLateRate > 0) {
                     // Calcula cuánto DEBERÍA haberse pagado hasta esta fecha
                    const expectedPaidByThisDate = installmentsDueCount * installmentAmount;
                    // Calcula cuánto falta por pagar de lo vencido
                    const outstandingDueAmount = Math.max(0, expectedPaidByThisDate - currentTotalPaid);

                    // Si hay monto vencido pendiente, calcula la mora diaria sobre ESE monto
                    if (outstandingDueAmount > 0) {
                        const dailyFee = outstandingDueAmount * dailyLateRate;
                        accumulatedLateFees += dailyFee;
                        accumulatedLateDays++; // Solo contamos días de mora si había saldo pendiente ESE día
                    }
                } else {
                     // Si no hay tasa de mora, solo contamos días de atraso si la cuota está pendiente
                     const expectedPaidByThisDate = installmentsDueCount * installmentAmount;
                     if (currentTotalPaid < expectedPaidByThisDate) {
                         accumulatedLateDays++;
                     }
                }
            }

            // Si la fecha es HOY, marca cuánto se debe pagar hoy
            if (checkDate.getTime() === today.getTime()) {
                details.amountDueToday = installmentAmount;
            }

            // Guarda la próxima fecha de vencimiento (la primera que encuentre a partir de hoy)
            if (checkDate >= today && !nextDueDateFound) {
                details.nextDueDate = new Date(checkDate);
                nextDueDateFound = true;
            }
        }

        // Avanza al siguiente día (importante: hacerlo fuera del if de isPaymentDay)
        checkDate.setDate(checkDate.getDate() + 1);
    }

    // --- Determinar Estado Final ---
    details.lateDays = accumulatedLateDays;
    details.lateFeesAccumulated = accumulatedLateFees;

    const totalInstallments = parseInt((loan.installments || '0/0').split('/')[1]);
    const paidInstallmentsCalculated = Math.floor(currentTotalPaid / installmentAmount);

    if (paidInstallmentsCalculated >= totalInstallments || currentTotalPaid >= loan.totalLoan) {
         details.status = 'finished';
    } else if (accumulatedLateDays > 1) { // Más de 1 día de atraso (considerando mora o no)
        details.status = 'late';
    } else if (details.amountDueToday > 0 && currentTotalPaid < installmentsDueCount * installmentAmount) { // Si hoy es día de pago y no está cubierto
         details.status = 'pending';
    } else if (accumulatedLateDays === 1) { // Exactamente 1 día de atraso
         details.status = 'pending'; // Consideramos 'pending' el primer día, 'late' a partir del segundo
    } else {
        details.status = 'paid'; // Si no está terminado, ni atrasado, ni pendiente hoy, está al día.
    }

    return details;
}


        function calculateLatePaymentDays(loan) {
            if (!loan || (loan.paid || 0) >= (loan.totalLoan || 0)) return 0;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let lastRelevantDate;
            if (loan.history && loan.history.length > 0) {
                const sortedHistory = [...loan.history]
                    .filter(h => h.date?.seconds && h.status !== 'pending_verification')
                    .sort((a, b) => b.date.seconds - a.date.seconds);
                if (sortedHistory.length > 0) lastRelevantDate = new Date(sortedHistory[0].date.seconds * 1000);
            } 
            if (!lastRelevantDate) {
                if (loan.startDate?.seconds) {
                    lastRelevantDate = new Date(loan.startDate.seconds * 1000);
                } else {
                     return 0;
                }
            }
            
            let lateDays = 0;
            let checkDate = new Date(lastRelevantDate);
            checkDate.setDate(checkDate.getDate() + 1); // Empezamos a contar desde el día siguiente al último pago/inicio

            while (checkDate <= today) {
                const dayOfWeek = checkDate.getDay();
                const dateString = ('0' + checkDate.getDate()).slice(-2) + '/' + ('0' + (checkDate.getMonth() + 1)).slice(-2);
                
                if (dayOfWeek !== 0 && !nationalHolidays.includes(dateString)) {
                    lateDays++;
                }
                checkDate.setDate(checkDate.getDate() + 1);
            }
            return lateDays;
        }

        function renderLoanTabs() {
            const tabsContainer = document.getElementById('loan-tabs-container');
            if (!tabsContainer || !currentClient || !currentClient.loans) return; // Añade chequeo de loans

            // --- INICIO: CORRECCIÓN ESTADO OBSOLETO ---
            // 1. Mapea y RECALCULA el estado de CADA préstamo ANTES de filtrar
            const loansWithStatusAndIndex = currentClient.loans.map((loan, index) => {
                const details = calculateLoanDetails(loan); // Calcula estado real
                return { 
                    ...loan, 
                    calculatedStatus: details.status, // Guarda el estado calculado
                    originalIndex: index 
                };
            });

            // 2. Filtra usando el estado RECALCULADO ('calculatedStatus')
            const displayableLoans = loansWithStatusAndIndex.filter(l => l.calculatedStatus !== 'finished');
            // --- FIN: CORRECCIÓN ---

            // Muestra pestañas si hay MÁS DE UNO no finalizado
            if (displayableLoans.length > 1) {
                tabsContainer.style.display = 'flex';
                // Renderiza usando 'originalIndex' y comparando con 'selectedLoanIndex' global
                tabsContainer.innerHTML = displayableLoans.map((loan) => `
                    <button class="loan-tab ${loan.originalIndex === selectedLoanIndex ? 'active' : ''}" data-index="${loan.originalIndex}">
                        ${translations[currentLang].loanLabel} ${loan.originalIndex + 1}
                    </button>
                `).join('');
            } else {
                tabsContainer.style.display = 'none'; // Oculta si solo hay uno (o ninguno) activo
            }
        }

        function updateReputationView() {
             if (!currentClient || !document.getElementById('reputation-card')) return;
            
            const currentLoan = (currentClient.loans || [])[selectedLoanIndex];
            if (!currentLoan) return;

            const lateDays = calculateLatePaymentDays(currentLoan);
            const score = Math.max(0, 10 - lateDays); 

            const bar = document.getElementById('reputation-bar');
            const valueEl = document.getElementById('reputation-value');
            const textEl = document.getElementById('reputation-text');

            bar.style.width = `${score * 10}%`;
            valueEl.textContent = `${score} / 10`;

            bar.className = 'reputation-bar'; // Reset classes
            textEl.className = 'reputation-text';

            if (score === 10) {
                bar.classList.add('status-perfect');
                textEl.classList.add('status-perfect');
                textEl.textContent = translations[currentLang].reputationPerfect;
            } else if (score >= 7) {
                bar.classList.add('status-good');
                textEl.classList.add('status-good');
                textEl.textContent = translations[currentLang].reputationGood;
            } else if (score >= 3) {
                bar.classList.add('status-regular');
                textEl.classList.add('status-regular');
                textEl.textContent = translations[currentLang].reputationRegular;
            } else {
                bar.classList.add('status-bad');
                textEl.classList.add('status-bad');
                textEl.textContent = translations[currentLang].reputationBad;
            }
        }

        function showView(viewName) {
    // Oculta todas las vistas y desactiva ítems de navegación (sin cambios)
    document.querySelectorAll('.view').forEach(view => view.classList.remove('active'));
    document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));

    // Muestra la vista solicitada (sin cambios)
    const activeView = document.getElementById(`${viewName}-view`);
    if (activeView) {
        activeView.classList.add('active');
    } else {
         // Fallback si la vista no existe, vuelve a home
         console.warn(`Vista "${viewName}" no encontrada, volviendo a home.`);
         viewName = 'home'; // Actualiza viewName para lógica posterior
         document.getElementById('home-view')?.classList.add('active');
    }

    // Activa el ítem de navegación correspondiente (sin cambios)
    const activeNavItem = document.querySelector(`.nav-item[data-view="${viewName}"]`);
    if (activeNavItem) {
        activeNavItem.classList.add('active');
    }

    // --- [INICIO CÓDIGO AÑADIDO/MODIFICADO] ---
    // Llama a la función de actualización específica para la vista que se está mostrando AHORA.
    // Es crucial hacerlo DESPUÉS de añadir la clase 'active' a la vista.
    console.log(`[CLIENTE-APP][DIAG-UI] Mostrando vista: ${viewName}. Llamando a función de actualización...`);
    try {
        switch (viewName) {
            case 'home':
                if (currentClient) updateDashboardView(); // Actualiza el dashboard
                break;
            case 'pay':
                if (currentClient && collectorSettings) updatePayView(); // Actualiza la vista de pago
                break;
            case 'refinance':
                if (currentClient) updateRefinanceView(); // Actualiza la vista de refinanciamiento
                break;
            case 'notifications':
                if (currentClient) updateNotificationsView(); // Actualiza la lista de notificaciones
                break;
            case 'profile':
                if (currentClient) updateProfileView(); // Actualiza la vista de perfil
                break;
            // Añade casos para otras vistas si existen
            default:
                 console.warn(`[CLIENTE-APP][DIAG-UI] No hay función de actualización específica para la vista: ${viewName}`);
        }
         console.log(`[CLIENTE-APP][DIAG-UI] Función de actualización para ${viewName} completada.`);
    } catch (updateError) {
         // Captura errores que puedan ocurrir DENTRO de las funciones update...View()
         console.error(`[CLIENTE-APP][DIAG-UI] !!! ERROR al actualizar la vista ${viewName}:`, updateError);
         showToast(`Erro ao carregar conteúdo da aba ${viewName}.`, true);
    }

        }

        function updateDashboardView() {
            if (!currentClient || !document.getElementById('home-view') || !currentClient.loans || currentClient.loans.length === 0) return;
            
            const currentLoan = currentClient.loans[selectedLoanIndex];
            if (!currentLoan) return;

            const historyPaid = (currentLoan.history || [])
                .filter(h => h.status === 'approved' || (!h.status && h.date))
                .reduce((sum, h) => sum + (h.amount || 0), 0);

            // 2. Obtiene el valor inicial migrado
            const initialPaid = currentLoan.initialMigratedAmount || 0;
            
            // 3. El total real es la suma de ambos
            const paidAmount = initialPaid + historyPaid;
                
            const totalAmount = currentLoan.totalLoan || 0;
            const remainingAmount = Math.max(0, totalAmount - paidAmount);

            const loanDetails = calculateLoanDetails(currentLoan); 
            currentLoan.status = loanDetails.status; 

            const originalInstallment = currentLoan.originalInstallmentAmount || 1; 
            const totalInstallments = currentLoan.installments ? parseInt((currentLoan.installments || '0/0').split('/')[1], 10) : 0;
            const paidInstallments = totalInstallments > 0 ? Math.min(totalInstallments, Math.floor(paidAmount / originalInstallment)) : 0;
            const progressPercentage = totalInstallments > 0 ? (paidInstallments / totalInstallments) * 100 : 0;
            // --- FIN: CÁLCULO DE PROGRESO (Sin cambios) ---
            
            const circleCircumference = 2 * Math.PI * 54;
            const strokeDashoffset = circleCircumference - (progressPercentage / 100) * circleCircumference;

            let historyHtml = `<p class="no-history" data-lang-key="noPayments">${translations[currentLang].noPayments}</p>`;
            
            if (currentLoan.history && currentLoan.history.length > 0) {
                
                // --- [INICIO DE LA LÓGICA DE ETIQUETAS] ---
                const now = new Date();
                const twentyFourHoursAgo = now.getTime() - (24 * 60 * 60 * 1000);

                // 1. Filtra los pagos a mostrar (Sin cambios)
                const filteredHistory = [...currentLoan.history]
                    .filter(p => {
                        if (!p.date?.seconds) return false;
                        const paymentTimestamp = p.date.seconds * 1000;
                        const isApproved = p.status === 'approved' || (!p.status && p.date);
                        const isRecentPending = p.status === 'pending_verification' && paymentTimestamp >= twentyFourHoursAgo;
                        return isApproved || isRecentPending;
                    })
                    .sort((a, b) => a.date.seconds - b.date.seconds);

                // 2. Mapea los pagos filtrados (Sin cambios en los cálculos)
                let approvedCumulativePaidForNumbering = currentLoan.initialMigratedAmount || 0;
                
                const paymentDetails = filteredHistory.map(p => {
                    const paymentAmount = p.amount || 0;
                    let title = '';
                    let description = '';

                    const startInstallmentNum = (originalInstallment > 0) 
                        ? Math.floor(approvedCumulativePaidForNumbering / originalInstallment) + 1 
                        : 1; 

                    const remainingInCurrentInstallment = (originalInstallment > 0)
                        ? originalInstallment - (approvedCumulativePaidForNumbering % originalInstallment)
                        : 0;
                    
                    const installmentBalanceBeforePayment = (remainingInCurrentInstallment === 0 && approvedCumulativePaidForNumbering > 0 && originalInstallment > 0) 
                        ? originalInstallment 
                        : remainingInCurrentInstallment;

                    
                    if (p.status === 'approved' || (!p.status && p.date)) {
                        
                        const cumulativeAfterPayment = approvedCumulativePaidForNumbering + paymentAmount;
                        
                        const endInstallmentNum = (originalInstallment > 0)
                            ? Math.floor((cumulativeAfterPayment - 0.01) / originalInstallment) + 1
                            : 1;

                        const partialPercentRaw = (originalInstallment > 0)
                            ? cumulativeAfterPayment % originalInstallment
                            : 0;
                        const partialPercent = Math.round(partialPercentRaw);
                        
                        // --- [INICIO DE LA CORRECCIÓN DEL BUG] ---
                        // Caso 1: El pago NO cruza a una nueva cuota (startInstallmentNum === endInstallmentNum)
                        if (startInstallmentNum === endInstallmentNum) {
                            title = translations[currentLang].paymentInstallmentTitle.replace('{installment}', startInstallmentNum);
                            
                            // Si el porcentaje es 0 (o muy cercano), significa que completó la cuota exactamente.
                            if (partialPercent < 0.01) {
                                description = translations[currentLang].fullPaymentDesc.replace('{installment}', startInstallmentNum);
                            } else {
                                // De lo contrario, es un pago parcial normal.
                                description = translations[currentLang].partialPaymentDesc.replace('{percent}', partialPercent);
                            }
                        // --- [FIN DE LA CORRECCIÓN DEL BUG] ---
                        
                        // Caso 2: Pago completa exactamente una o más cuotas (sin saldo)
                        } else if (startInstallmentNum < endInstallmentNum && partialPercent < 0.01) {
                            const fullInstallmentsCovered = endInstallmentNum - startInstallmentNum;
                            if (fullInstallmentsCovered === 1) {
                                title = translations[currentLang].paymentInstallmentTitle.replace('{installment}', startInstallmentNum);
                                description = translations[currentLang].fullPaymentDesc.replace('{installment}', startInstallmentNum);
                            } else {
                                title = translations[currentLang].paymentInstallmentsTitle
                                    .replace('{start}', startInstallmentNum)
                                    .replace('{end}', endInstallmentNum - 1); 
                                description = translations[currentLang].multipleFullPaymentDesc.replace('{count}', fullInstallmentsCovered);
                            }
                        
                        // Caso 3: Pago cruza a una nueva cuota Y DEJA SALDO
                        } else if (startInstallmentNum < endInstallmentNum && partialPercent >= 0.01) {
                             const fullInstallmentsCovered = endInstallmentNum - startInstallmentNum;
                             title = translations[currentLang].paymentInstallmentsTitle
                                .replace('{start}', startInstallmentNum)
                                .replace('{end}', endInstallmentNum);
                             description = translations[currentLang].multiplePaymentDesc
                                .replace('{count}', fullInstallmentsCovered)
                                .replace('{percent}', partialPercent);
                        } else {
                             title = "Pagamento Recebido";
                             description = "Valor creditado ao saldo.";
                        }

                        approvedCumulativePaidForNumbering += paymentAmount;

                    } else if (p.status === 'pending_verification') {
                         title = "Pagamento Enviado";
                         description = translations[currentLang].awaitingVerification;
                    }
                    // --- [FIN DE LA LÓGICA DE ETIQUETAS] ---

                    return {
                        ...p,
                        dateTimeString: new Date(p.date.seconds * 1000).toLocaleString(currentLang, { dateStyle: 'short', timeStyle: 'short'}),
                        title: title,
                        description: description,
                    };
                });
                
                // 3. Renderiza el HTML (Sin cambios)
                if (paymentDetails.length > 0) {
                    historyHtml = paymentDetails.reverse() 
                        .map(p => {
                             let statusTag = '';
                            if (p.status === 'pending_verification') {
                                statusTag = `<span class="payment-status-tag pending">${translations[currentLang].awaitingVerification}</span>`;
                            } else if (p.status === 'approved' || !p.status) {
                                statusTag = `<span class="payment-status-tag approved">${translations[currentLang].approved}</span>`;
                            }
                            
                            return `<div class="payment-history-item">
                                        <div class="payment-info">
                                            <h4 class="payment-title">${p.title}</h4>
                                            <p class="payment-description">${p.description}</p>
                                            <span class="payment-date">${p.dateTimeString}</span>
                                        </div>
                                        <div class="payment-status-wrapper">
                                            <span class="payment-amount" style="color: ${p.status === 'pending_verification' ? 'var(--text-secondary)' : 'var(--accent-green)'}">${money(p.amount)}</span>
                                            ${statusTag}
                                        </div>
                                    </div>`;
                        }).join('');
                } else {
                    historyHtml = `<p class="no-history" data-lang-key="noPayments">${translations[currentLang].noPayments}</p>`;
                }
            }
            
            // --- Actualización de KPIs (Sin cambios) ---
            document.getElementById('progress-text').textContent = `${paidInstallments}/${totalInstallments}`;
            document.getElementById('progress-bar').style.strokeDashoffset = strokeDashoffset;
            document.getElementById('total-value').textContent = money(totalAmount);
            document.getElementById('remaining-value').textContent = money(remainingAmount);
            document.getElementById('kpi-installment-value').textContent = money(currentLoan.originalInstallmentAmount || 0);
            
            document.getElementById('payment-history-list').innerHTML = historyHtml;
            
            updateReputationView();

            const payNavItem = document.querySelector('.nav-item[data-view="pay"]');
            if (payNavItem) {
                if (paidInstallments >= totalInstallments && totalInstallments > 0) {
                    payNavItem.classList.add('disabled');
                } else {
                    payNavItem.classList.remove('disabled');
                }
            }
            lucide.createIcons({nodes: document.getElementById('home-view').querySelectorAll('[data-lucide]')});
        }

        function updateProfileView() {
            if (!currentClient) return;
            const profileView = document.getElementById('profile-view');

            const nameInitial = (currentClient.name || 'C').charAt(0).toUpperCase();
            const placeholderUrl = `https://placehold.co/120x120/6f42c1/FFFFFF?text=${nameInitial}`;
            const photoUrl = currentClient.profilePictureUrl || placeholderUrl;

            profileView.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; margin-bottom: 30px;">
                    <label for="profile-pic-input" class="profile-pic-wrapper">
                        <img id="profile-view-img" src="${photoUrl}" alt="Foto do Cliente">
                    </label>
                    <input type="file" id="profile-pic-input" accept="image/*" style="display: none;">
                    <h2 style="margin: 15px 0 0; font-size: 1.5em;">${currentClient.name}</h2>
                    <p style="margin: 5px 0 0; color: var(--text-secondary);">${currentClient.username}</p>
                </div>
                
                <section>
                    <h2 class="section-title" data-lang-key="accountSettings"></h2>
                    <div class="settings-list">
                        <a class="settings-item logout" id="logout-btn">
                            <i data-lucide="log-out"></i><span data-lang-key="logout"></span>
                        </a>
                    </div>
                </section>
            `;

            lucide.createIcons({ nodes: profileView.querySelectorAll('[data-lucide]') });
            applyLanguage(currentLang);

            profileView.querySelector('#logout-btn').addEventListener('click', handleLogout);
        }

        
        function handleLogout() {
    if (unsubscribeClient) {
        unsubscribeClient();
        unsubscribeClient = null; // Limpa a referência
    }
    
    // --- INICIO DE LA CORRECCIÓN ---
    // Añadimos la limpieza para el listener del cobrador
    if (unsubscribeCollector) {
        unsubscribeCollector();
        unsubscribeCollector = null;
    }
    // --- FIN DE LA CORRECCIÓN ---

    if (notificationInterval) {
        clearInterval(notificationInterval);
        notificationInterval = null; // Limpa a referência
    }

    // Chama o signOut oficial do Firebase Auth
    signOut(auth).catch((error) => {
        console.error("[CLIENTE-APP] Erro ao fazer logout:", error);
        showToast('Erro ao tentar sair.', true);
    });

    // Não precisamos mais limpar variáveis ou mostrar/ocultar vistas aqui.
    // O onAuthStateChanged será chamado com user=null e fará isso.
    console.log("[CLIENTE-APP] Logout iniciado. Aguardando onAuthStateChanged...");
}



        function updatePayView() {
            const payViewContainer = document.getElementById('pay-view');
            if (!payViewContainer) return;

            // --- Función interna para renderizar el formulario de pago ---
            // Esto se llamará después de seleccionar un préstamo o si solo hay uno.
            const renderAndSetupPaymentForm = (loanIndex) => {
                if (!collectorSettings || !collectorSettings.paymentSettings) {
                    console.warn("[CLIENTE-APP] renderAndSetupPaymentForm: No se encontraron collectorSettings.paymentSettings.");
                    return `<p class="no-history" data-lang-key="noPaymentMethodsConfigured"></p>`;
                }

                const settings = collectorSettings.paymentSettings;
                const activeMethods = Object.keys(settings.methods || {}).filter(id => settings.methods[id].active && settings.methods[id].data);

                let methodsHtml = `<h2 class="section-title" data-lang-key="paymentOptions"></h2>`;

                if (activeMethods.length === 0) {
                    methodsHtml += `<p class="no-history" data-lang-key="noPaymentMethodsConfigured"></p>`;
                } else {
                    methodsHtml += activeMethods.map(id => {
                        const methodConfig = PAYMENT_CONFIGS[settings.currency]?.methods.find(m => m.id === id);
                        const methodData = settings.methods[id].data;
                        if (!methodConfig) return '';

                        if (methodConfig.type === 'image') {
                            return `<div class="kpi-card" style="margin-bottom: 20px;">
                                        <h3 class="kpi-title">${methodConfig.label}</h3>
                                        <img src="${methodData}" alt="${methodConfig.label}" style="max-width: 200px; margin: 10px auto; display: block; border-radius: 8px;">
                                    </div>`;
                        } else if (methodConfig.type === 'textarea') {
                            return `<div class="kpi-card" style="margin-bottom: 20px;">
                                        <h3 class="kpi-title">${methodConfig.label}</h3>
                                        <textarea class="form-control" rows="4" readonly style="background-color: var(--border-color);">${methodData}</textarea>
                                        <button class="btn-primary copy-btn" data-copy="${methodData}" style="width:100%; margin-top:10px;"><i data-lucide="copy"></i> <span data-lang-key="copyCode"></span></button>
                                    </div>`;
                        } else {
                            return `<div class="kpi-card" style="margin-bottom: 20px;">
                                        <h3 class="kpi-title">${methodConfig.label}</h3>
                                        <div style="display:flex; gap:10px; align-items:center;">
                                            <strong style="background-color: var(--border-color); padding: 10px; border-radius: 8px; flex-grow:1; text-align: center; overflow-wrap: break-word;">${methodData}</strong>
                                            <button class="btn-primary copy-btn" data-copy="${methodData}" style="flex-shrink:0;"><i data-lucide="copy"></i></button>
                                        </div>
                                    </div>`;
                        }
                    }).join('');
                }

                // Formulario de envío de recibo
                methodsHtml += `
                    <div class="kpi-card" style="margin-top: 30px;">
                        <h3 class="section-title" data-lang-key="uploadReceipt"></h3>
                        <p style="font-size: 0.9em; color: var(--text-secondary); margin-top: -10px; margin-bottom: 15px;">Para el Préstamo ${loanIndex + 1}</p>
                        <div class="form-group">
                            <label for="receipt-amount" data-lang-key="paymentAmountLabel"></label>
                            <input type="number" id="receipt-amount" step="0.01" placeholder="0.00" class="form-control">
                        </div>
                        <label for="receipt-file-input" class="upload-receipt-btn">
                            <i data-lucide="upload-cloud"></i>
                            <span id="upload-label-text">Clique para anexar</span>
                            <img id="receipt-preview" style="display:none;">
                        </label>
                        <input type="file" id="receipt-file-input" accept="image/*" style="display:none;">
                        
                        <!-- ESTE BOTÓN AHORA LLEVA EL ÍNDICE DEL PRÉSTAMO -->
                        <button class="btn-primary" id="submit-receipt-btn" data-loan-index="${loanIndex}" style="width:100%; margin-top:15px;" disabled>
                            <i data-lucide="send"></i> <span data-lang-key="submitForVerification"></span>
                        </button>
                    </div>`;
                
                return methodsHtml; // Devuelve el HTML del formulario
            };

            // --- Función interna para configurar los listeners del formulario ---
            const setupPaymentFormListeners = (container) => {
                container.querySelectorAll('.copy-btn').forEach(btn => {
                    btn.addEventListener('click', () => copyToClipboard(btn.dataset.copy, translations[currentLang].copied));
                });
                
                const fileInput = container.querySelector('#receipt-file-input');
                const submitBtn = container.querySelector('#submit-receipt-btn');
                
                if (fileInput) {
                    fileInput.addEventListener('change', e => {
                        if (e.target.files && e.target.files[0]) {
                            receiptFile = e.target.files[0];
                            const preview = container.querySelector('#receipt-preview');
                            const uploadLabel = container.querySelector('#upload-label-text');
                            preview.src = URL.createObjectURL(receiptFile);
                            preview.style.display = 'block';
                            uploadLabel.style.display = 'none';
                            if(submitBtn) submitBtn.disabled = false;
                        }
                    });
                }
                
                if (submitBtn) {
                    submitBtn.addEventListener('click', e => {
                        handleReceiptSubmission(e.currentTarget); // Pasa el botón (que tiene el data-loan-index)
                    });
                }
            };

            // --- Lógica principal de updatePayView ---

            if (!collectorSettings || !collectorSettings.paymentSettings) {
                payViewContainer.innerHTML = `<h2 class="section-title" data-lang-key="paymentOptions"></h2><p class="no-history" data-lang-key="noPaymentMethodsConfigured"></p>`;
                applyLanguage(currentLang);
                return;
            }

            // 1. Encontrar todos los préstamos activos (no finalizados)
            const activeLoans = (currentClient.loans || [])
                .map((loan, index) => ({ ...loan, originalIndex: index })) // Guardar el índice original
                .filter(loan => {
                    if (!loan.totalLoan) return false; // Ignorar si no es un préstamo válido
                    const details = calculateLoanDetails(loan); // Recalcular estado
                    return details.status !== 'finished';
                });

            // 2. Decidir qué mostrar
            if (activeLoans.length === 0) {
                // Caso 0: No hay préstamos activos
                payViewContainer.innerHTML = `<h2 class="section-title" data-lang-key="paymentOptions"></h2><p class="no-history" data-lang-key="loanFinished"></p>`;
                applyLanguage(currentLang);

            } else if (activeLoans.length === 1) {
                // Caso 1: Solo un préstamo activo. Mostrar formulario directamente.
                const loanIndex = activeLoans[0].originalIndex;
                payViewContainer.innerHTML = renderAndSetupPaymentForm(loanIndex);
                setupPaymentFormListeners(payViewContainer); // Configurar listeners para el contenedor principal
                applyLanguage(currentLang);
                lucide.createIcons({nodes: payViewContainer.querySelectorAll('[data-lucide]')});

            } else {
                // Caso 2: Múltiples préstamos activos. Mostrar selector.
                const selectorHtml = `
                    <h2 class="section-title" data-lang-key="payInstallment"></h2>
                    <div class="kpi-card" style="margin-bottom: 20px;">
                        <h3 class="kpi-title" style="font-size: 1.1em; color: var(--text-primary);">Seleccione el préstamo a pagar</h3>
                        <div id="loan-payment-selector">
                            ${activeLoans.map(loan => {
                                const remaining = Math.max(0, loan.totalLoan - (loan.paid || 0));
                                return `
                                <label style="display:flex; padding: 15px; border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 10px; align-items: center; gap: 10px; cursor: pointer;">
                                    <input type="radio" name="paymentLoan" value="${loan.originalIndex}" style="width: 20px; height: 20px; flex-shrink: 0;">
                                    <div>
                                        <strong style="font-size: 1.1em;">${translations[currentLang].loanLabel} ${loan.originalIndex + 1}</strong>
                                        <div style="font-size: 0.9em; color: var(--text-secondary);">
                                            Restante: ${money(remaining)} | Cuota: ${money(loan.originalInstallmentAmount)}
                                        </div>
                                    </div>
                                </label>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    <div id="payment-form-container" style="display: none; opacity: 0; transition: opacity 0.3s ease-in-out;">
                        <!-- El formulario de pago se inyectará aquí -->
                    </div>
                `;
                payViewContainer.innerHTML = selectorHtml;
                applyLanguage(currentLang);

                // Añadir listener para los botones de radio
                const selector = payViewContainer.querySelector('#loan-payment-selector');
                selector.addEventListener('change', (e) => {
                    const selectedLoanIndex = parseInt(e.target.value, 10);
                    if (!isNaN(selectedLoanIndex)) {
                        const formContainer = payViewContainer.querySelector('#payment-form-container');
                        formContainer.innerHTML = renderAndSetupPaymentForm(selectedLoanIndex);
                        setupPaymentFormListeners(formContainer); // Configurar listeners para el contenedor del formulario
                        
                        formContainer.style.display = 'block';
                        setTimeout(() => { formContainer.style.opacity = 1; }, 10); // Fade in
                        
                        applyLanguage(currentLang);
                        lucide.createIcons({nodes: formContainer.querySelectorAll('[data-lucide]')});
                    }
                });
            }
        }

        
        function updateRefinanceView() {
            if (!currentClient || !document.getElementById('refinance-view')) return;
            const container = document.getElementById('refinance-view');
            const currentLoan = currentClient.loans[selectedLoanIndex];
            if (!currentLoan) return;

            const lateDays = calculateLatePaymentDays(currentLoan);
            const score = Math.max(0, 10 - lateDays);
            let content = '';

            // --- INICIO: LÓGICA CORREGIDA ---
            // Solo comprueba la puntuación. Si es 10, muestra el formulario.
            if (score === 10) { 
                content = `<div class="container">
                               <h2 class="section-title" data-lang-key="refinanceTitle"></h2>
                               <div class="kpi-card">
                                   <form id="refinance-form">
                                       <div class="form-group">
                                           <label for="refinance-amount" data-lang-key="newAmount"></label>
                                           <input type="number" id="refinance-amount" class="form-control" required>
                                       </div>
                                       <div class="form-group">
                                           <label for="refinance-installments" data-lang-key="newInstallments"></label>
                                           <input type="number" id="refinance-installments" class="form-control" required>
                                       </div>
                                       <button type="submit" class="btn-primary" style="width:100%;">
                                           <span data-lang-key="sendForAnalysis"></span>
                                       </button>
                                   </form>
                               </div>
                               ${currentClient.refinanceRequest ? `<p style="text-align: center; margin-top: 15px; font-size: 0.9em; color: var(--text-secondary);">${translations[currentLang].analysisSent}</p>` : ''}
                           </div>`;
            } else { // Si la puntuación no es 10, muestra el mensaje de mejora.
                content = `<div class="container kpi-card">
                               <h2 class="section-title" data-lang-key="reputationNotGoodTitle"></h2>
                               <p>${translations[currentLang].reputationNotGoodMsg}</p>
                           </div>`;
            }
            // --- FIN: LÓGICA CORREGIDA ---

            container.innerHTML = content;
            applyLanguage(currentLang);
            
            const form = document.getElementById('refinance-form');
            if (form) {
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const amountInput = document.getElementById('refinance-amount');
                    const installmentsInput = document.getElementById('refinance-installments');
                    const submitBtn = form.querySelector('button[type="submit"]'); // <-- Captura el botón
                    const originalBtnHTML = submitBtn.innerHTML; // <-- Guarda HTML original

                    const amount = parseFloat(amountInput.value);
                    const installments = parseInt(installmentsInput.value, 10);
                    
                    if (isNaN(amount) || amount <= 0 || isNaN(installments) || installments <= 0) {
                        showToast(translations[currentLang].invalidAmount, true);
                        return;
                    }

                    // --- INICIO: Añadir indicador de carga ---
                    submitBtn.disabled = true;
                    submitBtn.innerHTML = `<i data-lucide="loader-circle" style="animation: spin 1s linear infinite;"></i>`;
                    lucide.createIcons({ nodes: [submitBtn.querySelector('i')] });
                    // --- FIN: Añadir indicador de carga ---

                    try {
                        const clientRef = doc(db, 'companies', currentCompanyId, 'clients', currentClientId);
                        // Guarda la nueva solicitud (sobrescribe la anterior si existía)
                        await updateDoc(clientRef, { 
                            refinanceRequest: { 
                                amount: amount, 
                                installments: installments, 
                                requestDate: new Date(), // Usa new Date() en lugar de serverTimestamp para consistencia
                                status: 'pending' 
                            } 
                        });
                        showToast(translations[currentLang].analysisSent);
                        // Llama a la función para notificar al cobrador (esta ya estaba correcta)
                        sendNotificationToCollector(
                            `${currentClient.name}`, 
                            `${translations[currentLang].refinanceRequested} ${money(amount)}.`, 
                            'refinance', // tipo
                            'trending-up' // icono
                        );
                        // Actualiza la vista para mostrar "Solicitação enviada" de nuevo
                        updateRefinanceView(); 

                    } catch (error) {
                        console.error("Error sending refinance request:", error);
                        showToast(translations[currentLang].genericError, true);
                        // --- INICIO: Restaurar botón en error ---
                        submitBtn.disabled = false;
                        submitBtn.innerHTML = originalBtnHTML;
                        // --- FIN: Restaurar botón en error ---
                    } 
                    // No necesitamos 'finally' aquí si no restauramos el botón en caso de éxito
                });
            }
        }





        function updateNotificationsView() {
            if (!currentClient || !document.getElementById('notifications-list')) return;

            const listContainer = document.getElementById('notifications-list');
            const notifications = currentClient.notifications || [];
            const unreadCount = notifications.filter(n => !n.read).length;
            
            const badge = document.querySelector('.nav-item[data-view="notifications"] .notification-badge');
            if (badge) {
                badge.style.display = unreadCount > 0 ? 'block' : 'none';
            }
            
            if (notifications.length === 0) {
                listContainer.innerHTML = `<p class="no-notifications" data-lang-key="noNotifications">${translations[currentLang].noNotifications}</p>`;
                return;
            }
            
            listContainer.innerHTML = [...notifications].reverse().map((n, index) => {
                const d = n.timestamp.toDate();
                const dateString = d.toLocaleString(currentLang, { dateStyle: 'medium', timeStyle: 'short' });
                const isUnread = n.read === false;
                const notifId = n.id || `notif_${notifications.length - 1 - index}`; 
                
                return `
                    <div class="notification-item ${isUnread ? 'unread' : ''}" data-id="${notifId}">
                        <div class="notification-icon"><i data-lucide="${n.icon || 'info'}"></i></div>
                        <div class="notification-content">
                            <h4 class="notification-title">${n.title}</h4>
                            <p class="notification-body">${n.body}</p>
                            <p class="notification-date">${dateString}</p>
                        </div>
                    </div>
                `;
            }).join('');
            
            lucide.createIcons({ nodes: listContainer.querySelectorAll('[data-lucide]') });
        }

        function updateAllViews() {
            if (!currentClient) return;

            const nameInitial = (currentClient.name || 'C').charAt(0).toUpperCase();
            const placeholderUrl = `https://placehold.co/40x40/6f42c1/FFFFFF?text=${nameInitial}`;
            document.getElementById('header-profile-img').src = currentClient.profilePictureUrl || placeholderUrl;
            
            renderLoanTabs(); // Renderiza las pestañas de préstamos primero
            updateDashboardView();
            updateProfileView();
            updatePayView();
            updateNotificationsView();

            if (document.getElementById('refinance-view').classList.contains('active')) {
                updateRefinanceView();
            }

            applyLanguage(currentLang);
            lucide.createIcons();
        }

        
            async function setupFCM() {
    const LOG_PREFIX = `[CLIENTE-FCM-DIAGNOSTICO]`;
    console.log(`${LOG_PREFIX} --- Iniciando setupFCM ---`);
    try {
        if (!('Notification' in window) || !('serviceWorker' in navigator)) {
            console.error(`${LOG_PREFIX} ERROR: Notificações Push no son soportadas en este navegador.`);
            return;
        }
        console.log(`${LOG_PREFIX} El navegador soporta notificaciones.`);

        
        console.log(`${LOG_PREFIX} Esperando que el Service Worker esté listo...`);
                const registration = await navigator.serviceWorker.ready;
                console.log(`${LOG_PREFIX} ¡Service Worker listo y activo!`, registration);
                
                // Verificación adicional: Asegura que el SW esté controlando la página
                // A veces, el SW está listo pero aún no controla la página actual.
                if (!navigator.serviceWorker.controller) {
                    console.warn(`${LOG_PREFIX} Service Worker listo, pero aún no controla la página. Esperando activación...`);
                    // Espera un evento que indique que el controlador ha cambiado
                    await new Promise(resolve => navigator.serviceWorker.addEventListener('controllerchange', resolve, { once: true }));
                     console.log(`${LOG_PREFIX} ¡Service Worker ahora controla la página!`);
                } else {
                     console.log(`${LOG_PREFIX} Service Worker ya controla la página.`);
                }



                const messaging = getMessaging(app);
                console.log(`${LOG_PREFIX} Objeto de Messaging obtenido.`);

                console.log(`${LOG_PREFIX} Solicitando permiso del usuario...`);
                const permission = await Notification.requestPermission();
                console.log(`${LOG_PREFIX} El permiso del usuario es: ${permission}`);
                if (permission !== 'granted') {
                    console.warn(`${LOG_PREFIX} El usuario DENEGÓ el permiso para notificaciones.`);
                    showToast('Permiso para notificaciones denegado.', true);
                    return;
                }
                console.log(`${LOG_PREFIX} Permiso CONCEDIDO.`);

                if (!FCM_VAPID_KEY) {
                    console.error(`${LOG_PREFIX} ERROR FATAL: La VAPID key no está configurada.`);
                    showToast('Configuración de notificaciones incompleta (sin VAPID key).', true);
                    return;
                }
                console.log(`${LOG_PREFIX} VAPID Key encontrada y es válida.`);

                console.log(`${LOG_PREFIX} Obteniendo token de FCM... (Este paso puede tardar)`);
                const currentToken = await getToken(messaging, { 
                    vapidKey: FCM_VAPID_KEY,
                    serviceWorkerRegistration: registration // <-- AÑADIDO
                });

                if (currentToken) {
                console.log(`${LOG_PREFIX} ¡TOKEN OBTENIDO CON ÉXITO!: ${currentToken.substring(0, 30)}...`);
                // --- INÍCIO TAREFA CL6 (Correção Rota FCM Token) ---
                // Verifica se temos o ID GLOBAL do cliente (obtido no login, Tarefa CL1)
                if (currentClientId) {
                    // Lê os tokens existentes do objeto currentClient (que já tem os dados mais recentes via onSnapshot)
                    const existingTokens = currentClient?.fcmTokens || []; // Usa "?." por segurança

                    // Só atualiza se o token for realmente novo
                    if (!existingTokens.includes(currentToken)) {
                        console.log(`${LOG_PREFIX} El token es nuevo. Intentando guardar en Firestore (ruta global)...`);
                        // Define a referência para a ROTA GLOBAL: clients/{clientId}
                        
                    const clientRefGlobal = doc(db, 'companies', currentCompanyId, 'clients', currentClientId);

try {
    // Lee el documento MÁS RECIENTE justo antes de actualizar
    const clientSnap = await getDoc(clientRefGlobal);
    const currentData = clientSnap.data() || {}; // Obtiene datos actuales o un objeto vacío
    const currentTokens = currentData.fcmTokens || []; // Obtiene tokens actuales o array vacío

    // Solo actualiza si el token es realmente nuevo
    if (!currentTokens.includes(currentToken)) {
        console.log(`${LOG_PREFIX} El token es nuevo. Intentando guardar en Firestore (ruta global)...`);
        // Usa arrayUnion para añadir el nuevo token sin remover los existentes
        await updateDoc(clientRefGlobal, { fcmTokens: arrayUnion(currentToken) });
        console.log(`${LOG_PREFIX} ¡ÉXITO! Token nuevo guardado en Firestore (ruta global).`);
    } else {
        console.log(`${LOG_PREFIX} El token ya existía en Firestore (ruta global). No se requiere acción.`);
    }
} catch (error) {
    console.error(`${LOG_PREFIX} ERRO ao ler/salvar token FCM na rota global:`, error);
    showToast('Falha ao registrar dispositivo para notificações.', true);
}


                    } else {
                         console.log(`${LOG_PREFIX} El token ya existía en Firestore (ruta global). No se requiere acción.`);
                    }
                } else {
                     // Se não tivermos o currentClientId, não podemos salvar o token
                     console.warn(`${LOG_PREFIX} Se obtuvo un token FCM, pero falta currentClientId global. No se puede guardar.`);
                     // Considera mostrar um erro mais específico ou tentar obter o ID novamente
                }


                } else {
                    console.error(`${LOG_PREFIX} ERROR FATAL: No se pudo obtener el token. Causas comunes: 1) El archivo 'firebase-messaging-sw.js' no se encuentra en la raíz del sitio. 2) La VAPID key es incorrecta. 3) Problema de registro del Service Worker.`);
                    showToast('Falha ao obter token de notificação.', true);
                }

                onMessage(messaging, (payload) => {
    const LOG_PREFIX = `[CLIENTE-FCM-DIAGNOSTICO]`;
    console.log(`${LOG_PREFIX} Notificación recibida en PRIMER PLANO:`, payload);
    
    // [CORRECCIÓN] Ahora leemos el título y el cuerpo desde payload.data
    if (payload.data && payload.data.title && payload.data.body) {
        showToast(`${payload.data.title}: ${payload.data.body}`);
        
        // Simula una actualización de las notificaciones internas
        // Idealmente, aquí se debería llamar a una función que refresque la lista de notificaciones
        // Si tienes una función como `refreshInternalNotifications()`, llámala aquí.
        console.log(`${LOG_PREFIX} Actualizando la interfaz de notificaciones...`);
        
    } else {
        console.warn(`${LOG_PREFIX} El payload en primer plano no tiene el formato esperado.`, payload);
        showToast('Você recebeu uma nova notificação.');
    }
});

                console.log(`${LOG_PREFIX} --- setupFCM finalizado con éxito ---`);

            } catch (err) {
                console.error(`${LOG_PREFIX} ERROR CATASTRÓFICO en setupFCM:`, err);
                if (err.code === 'messaging/permission-blocked') {
                    showToast('As notificações estão bloqueadas. Ative-as nas configurações do seu navegador.', true);
                } else if (err.code === 'messaging/sw-registration-failed') {
                    showToast('Falha ao registrar o serviço de notificação.', true);
                } else {
                    showToast('Falha ao configurar as notificações push.', true);
                }
            }
        }

        function showMainApp(clientId, companyId) { // Recibe clientId y companyId
    // [INICIO CÓDIGO CORREGIDO] Verifica clientId y companyId, no authUid
    if (!clientId || !companyId) {
        console.error("[CLIENTE-APP] showMainApp chamada sem clientId ou companyId!"); // Mensaje corregido
        showBlockedView("Erro interno: IDs do cliente ou empresa não encontrados."); // Mensaje corregido
        // Considera si quieres desloguear aquí o no, tal vez solo mostrar el error.
        // signOut(auth); // Descomenta si quieres desloguear en este caso.
        return;
    }

    console.log(`[CLIENTE-APP] showMainApp iniciada para ClientID: ${clientId}, CompanyID: ${companyId}`);

    document.getElementById('login-view').style.display = 'none';
    document.getElementById('splash-screen').style.display = 'none'; // Garante que o splash está oculto
    document.getElementById('app-container').style.display = 'flex'; // Mostra o container principal

    // Renderiza o layout principal (cabeçalho, navegação) UMA VEZ
    // A flag evita re-renderizar em re-autenticações rápidas
    if (!document.body.dataset.layoutRendered) {
        
        lucide.createIcons(); // Cria ícones do layout base
        document.body.dataset.layoutRendered = 'true';
    }
    

    // Garante que listeners sejam adicionados apenas uma vez
    if (!document.body.dataset.listenersAttached) {
        setupEventListeners();
        document.body.dataset.listenersAttached = 'true';
    }

    // Mostra a vista inicial ou a do hash
    showView(location.hash.substring(1) || 'home');

    let isFirstLoad = true; // Flag para executar a configuração apenas uma vez
    let collectorData = null; // Redefinido aqui para clareza

    // Cancela o listener de cliente anterior se existir (importante ao re-logar)
    if (unsubscribeClient) {
        console.log("[COBRADOR-APP] Cancelando listener de cliente anterior.");
        unsubscribeClient();
        unsubscribeClient = null;
    }
    // TODO: Cancelar outros listeners (expenses, settlements) se eles também forem definidos globalmente.

    // Agora, usamos o authUid para encontrar o documento do cobrador correto
    
    console.log(`[CLIENTE-APP] Buscando documento do cobrador com authUid: ${currentAuthUid}...`); // <-- CORREGIDO: Usa global currentAuthUid
    
    if (!currentCollectorId) {
        // Si por alguna razón no tenemos el ID del cobrador, no podemos continuar.
        console.error("[CLIENTE-APP] ID do cobrador (collectorId) não encontrado nos dados do cliente.");
        showBlockedView("Erro: Não foi possível identificar o cobrador associado.");
        signOut(auth); // Deslogueamos porque es un error crítico de datos.
        return;
    }

    console.log(`[CLIENTE-APP] Buscando dados do cobrador com ID (username): ${currentCollectorId}...`);

    


    // Usamos onSnapshot directamente con el ID del cobrador para escuchar cambios
    
    // [REEMPLAZA EL BLOQUE onSnapshot DEL COBRADOR CON ESTO]
            unsubscribeCollector = onSnapshot(doc(db, 'collectors', currentCollectorId), (docSnap) => {
                if (docSnap.exists()) {
                    collectorSettings = docSnap.data(); // Guarda los datos del cobrador en la variable global 'collectorSettings'
                    console.log("[CLIENTE-APP] Dados do cobrador obtidos/atualizados:", collectorSettings);
        
                    // ... (código existente que estaba aquí, como updatePayView) ...
                    updatePayView(); // <-- Esta llamada está bien aquí

                    // Lógica de primeira carga (FCM) - Executa apenas uma vez após obter os dados iniciais
                    if (isFirstLoad) {
                        console.log('[CLIENTE-APP] Carga inicial do cobrador completa. Configurando FCM...');
                        setupFCM(); // La función setupFCM en cliente.html ya usa las variables globales correctas
                        
                        // --- [INICIO DE LA CORRECCIÓN] ---
                        // 1. Limpia cualquier intervalo anterior (por si acaso)
                        if (notificationInterval) clearInterval(notificationInterval);
                        
                        // 2. Inicia el verificador de notificaciones en un temporizador (cada 60 segundos)
                        // Esto evita que onSnapshot se llame a sí mismo en un bucle.
                        console.log("[CLIENTE-APP] Iniciando temporizador de verificação de atrasos (60s).");
                        
                        // [CORRECCIÓN 1/3] Ejecuta una vez al inicio
                        checkAndSendLatePaymentNotifications(); 
                        
                        // [CORRECCIÓN 2/3] Y luego lo ejecuta cada 60 segundos
                        notificationInterval = setInterval(checkAndSendLatePaymentNotifications, 60000); 
                        // --- [FIN DE LA CORRECCIÓN] ---

                        isFirstLoad = false; // Marca que la primera carga foi concluída
                    }
        
                    // --- INÍCIO LISTENERS MOVIDOS PARA DENTRO ---
                    // (Estes listeners agora começam DEPOIS de sabermos os dados do cobrador)
        
                    // Listener de CLIENTE (onSnapshot en el documento del cliente actual)
                    // Cancela listener anterior si existe
                    if (unsubscribeClient) unsubscribeClient();
                    console.log(`[CLIENTE-APP] Iniciando listener para cliente: companies/${currentCompanyId}/clients/${currentClientId}`);
                    unsubscribeClient = onSnapshot(doc(db, 'companies', currentCompanyId, "clients", currentClientId), (clientSnapshot) => {
                        
                        if (!clientSnapshot.exists() || !clientSnapshot.data()) {
                        console.error(`[CLIENTE-APP] Documento do cliente ${currentClientId} foi excluído, inacessível ou está vazio?`);
                        showBlockedView("Erro: Seus dados de cliente não puderam ser carregados ou estão corrompidos.");
                        signOut(auth);
                        return; // Detiene la ejecución si no hay datos válidos
                    }
                    console.log("[CLIENTE-APP] Dados do cliente atualizados via onSnapshot.");
                    currentClient = { id: clientSnapshot.id, ...clientSnapshot.data() }; // Actualiza datos globales del cliente
        
                    // Recalcula el estado de los préstamos solo si existen
                    // [CORRECCIÓN] Añadida verificación extra por si 'loans' no es un array
                    
        
                    if (currentClient && Array.isArray(currentClient.loans)) {
                    console.log("[CLIENTE-APP][DIAG-UI] Procesando préstamos..."); // <-- Log añadido
                    currentClient.loans.forEach(loan => {
                         if (!loan) return;
                        try { // <-- Añadir try/catch alrededor del cálculo
                             const loanDetails = calculateLoanDetails(loan);
                             loan.status = loanDetails.status;
                             loan.lateFeesAccumulated = loanDetails.lateFeesAccumulated;
                        } catch (calcError) {
                             console.error(`[CLIENTE-APP][DIAG-UI] ERROR en calculateLoanDetails para un préstamo:`, calcError, loan); // <-- Log de error específico
                        }
                    });
                    console.log("[CLIENTE-APP][DIAG-UI] Préstamos procesados. Llamando a updateAllViews()..."); // <-- Log añadido
                    try {
                        updateAllViews(); // <-- Llamada actual envuelta en try/catch
                        console.log("[CLIENTE-APP][DIAG-UI] ¡updateAllViews() completada com sucesso!"); // <-- Log añadido
                        
                        // --- [INICIO DE LA CORRECCIÓN] ---
                        // 3. ¡ELIMINAR LA LLAMADA DE AQUÍ!
                        // checkAndSendLatePaymentNotifications(); // <-- [CORRECCIÓN 3/3] LÍNEA ELIMINADA
                        // --- [FIN DE LA CORRECCIÓN] ---

                    } catch (updateError) {
                         console.error("[CLIENTE-APP][DIAG-UI] !!! ERROR DURANTE updateAllViews():", updateError); // <-- Log de error específico
                    }
                } else {
                     console.warn("[CLIENTE-APP][DIAG-UI] Cliente atualizado, mas 'loans' não é um array ou está ausente. Pulando recálculo y updateAllViews()."); // <-- Log modificado
                     // Si no hay préstamos, ¿deberíamos actualizar algo? Quizás el perfil.
                     try {
                         updateProfileView(); // Intentamos actualizar solo el perfil
                         console.log("[CLIENTE-APP][DIAG-UI] updateProfileView() llamada (sin préstamos).");
                     } catch (profileError) {
                          console.error("[CLIENTE-APP][DIAG-UI] !!! ERROR DURANTE updateProfileView() (sin préstamos):", profileError);
                     }
                }
        
        
                    }, (error) => {
                         console.error(`[CLIENTE-APP] Erro ao escutar dados do cliente ${currentClientId}:`, error);
                         showBlockedView("Erro de conexão ao carregar seus dados.");
                         signOut(auth);
                    });
        
                    // --- FIN LISTENERS MOVIDOS ---
        
        
                } else {
                    // Si el documento del cobrador no existe (¡muy raro!)
                    console.error(`[CLIENTE-APP] Documento do cobrador ${currentCollectorId} não existe!`);
                    showBlockedView("Erro crítico: Os dados do seu cobrador não foram encontrados.");
                    signOut(auth);
                }
            }, (error) => { // Manejo de erro para onSnapshot do cobrador
                console.error(`[CLIENTE-APP] Erro ao escutar dados do cobrador ${currentCollectorId}:`, error);
                showBlockedView("Erro de conexão ao carregar dados do cobrador.");
                signOut(auth);
            });
    
     // Fim do getDocs().catch()
}
        
        // --- INÍCIO: REEMPLAZO COMPLETO CORREGIDO (v2) TAREFA CL5 (showCropperModal) ---
function showCropperModal(file) {
    const cropperModal = document.getElementById('cropperModal');
    if (!cropperModal) {
        console.error("Elemento #cropperModal não encontrado!");
        return;
    }

    // Limpa conteúdo anterior e recria o HTML do modal para garantir estado limpo
    cropperModal.innerHTML = `
        <header class="modal-header">
            <button id="closeCropperModal"><i data-lucide="x"></i></button>
            <span class="modal-title" data-lang-key="cropImage"></span>
        </header>
        <div class="modal-content-wrapper">
            <div id="cropper-container" class="container" style="height: calc(100% - 60px);"> <!-- Ajuste altura container -->
                 <img id="cropper-image" style="max-width: 100%; display: block;"> <!-- display:block importante -->
            </div>
        </div>
        <div class="action-buttons">
            <button class="btn-secondary" id="cancelCropBtn"><span data-lang-key="cancel"></span></button>
            <button class="btn-primary" id="confirmCropBtn"><i data-lucide="check"></i> <span data-lang-key="confirmCrop"></span></button>
        </div>`;

    // Ativa o modal e aplica idioma/ícones
    history.pushState({ modal: 'cropperModal' }, 'Crop Image', '#crop'); // Adiciona estado ao histórico para botão voltar
    cropperModal.classList.add('active');
    lucide.createIcons({nodes: cropperModal.querySelectorAll('[data-lucide]')});
    applyLanguage(currentLang);

    // Elementos e variáveis do Cropper
    const image = document.getElementById('cropper-image');
    const reader = new FileReader();
    let cropper; // Instância do Cropper.js

    // Função para fechar e limpar o modal de forma segura
    const closeModal = () => {
         if(cropper) {
             try {
                 cropper.destroy(); // Libera recursos do Cropper
                 console.log("[CLIENTE-APP] Instância do Cropper destruída.");
             } catch (e) { console.warn("Erro ao destruir cropper (pode já ter sido destruído):", e); }
             cropper = null; // Limpa a referência
         }
         // Verifica se o modal ainda existe antes de remover a classe
         const modalEl = document.getElementById('cropperModal');
         if (modalEl) modalEl.classList.remove('active');
         console.log("[CLIENTE-APP] Modal de recorte fechado.");
    };

    // Lê o arquivo de imagem e inicializa o Cropper.js
    reader.onload = e => {
        if (image) { // Verifica se o elemento da imagem existe
            image.src = e.target.result; // Define a imagem base
            if(cropper) cropper.destroy(); // Garante destruir instância anterior
            // Inicializa o Cropper com opções para recorte quadrado
            cropper = new Cropper(image, {
                 aspectRatio: 1,       // Força recorte quadrado (1:1)
                 viewMode: 1,          // Restringe a área de corte à tela da imagem
                 background: false,    // Sem fundo quadriculado no recorte
                 autoCropArea: 0.8,    // Área de corte inicial (80% da imagem)
                 responsive: true,     // Permite redimensionar o cropper
                 checkOrientation: false // Evita rotação automática indesejada
            });
            console.log("[CLIENTE-APP] Cropper inicializado.");
        } else {
             console.error("Elemento #cropper-image não encontrado ao inicializar Cropper.");
             showToast("Erro ao inicializar ferramenta de recorte.", true);
             closeModal();
        }
    };
    reader.onerror = error => {
        console.error("Erro ao ler arquivo para recorte:", error);
        showToast("Erro ao carregar imagem para recorte.", true);
        closeModal();
    };
    reader.readAsDataURL(file); // Inicia a leitura do arquivo

    // --- Adiciona listeners aos botões DO MODAL RECRIADO ---
    const closeBtn = document.getElementById('closeCropperModal');
    const cancelBtn = document.getElementById('cancelCropBtn');
    const confirmBtn = document.getElementById('confirmCropBtn');

    // Usa window.history.back() para fechar, aproveitando o popstate listener
    if(closeBtn) closeBtn.addEventListener('click', () => window.history.back());
    if(cancelBtn) cancelBtn.addEventListener('click', () => window.history.back());

    // Listener para o botão "Confirmar Recorte"
    if(confirmBtn) {
        confirmBtn.addEventListener('click', () => {
            if (!cropper) { // Verificação de segurança
                 console.error("Instância do Cropper não encontrada ao confirmar recorte.");
                 showToast("Erro: Ferramenta de recorte não iniciada.", true);
                 return;
            }

            // Obtém a imagem recortada como um Blob (arquivo binário)
            cropper.getCroppedCanvas({
                width: 256, // Define o tamanho da imagem de saída (ex: 256x256 pixels)
                height: 256,
                imageSmoothingQuality: 'high' // Qualidade da imagem
            }).toBlob(async (blob) => { // INICIO do callback async (blob)
                if (!blob) { // Verifica se o blob foi gerado
                     console.error("Cropper não retornou blob ao recortar.");
                     showToast('Erro ao recortar imagem.', true);
                     return;
                }

                // Feedback visual: adiciona classe 'loading' à imagem de perfil na UI
                const profileViewImg = document.getElementById('profile-view-img');
                if(profileViewImg) profileViewImg.classList.add('loading');

                closeModal(); // Fecha o modal de recorte ANTES de iniciar o upload

                // --- Bloco TRY/CATCH para UPLOAD no Firebase Storage e SALVAR URL no Firestore ---
                try {
                    // Verifica se temos os IDs necessários (companyId, clientId)
                    if (!currentCompanyId || !currentClientId) throw new Error("IDs não definidos para upload de foto de perfil.");

                    // 1. Define a RUTA específica no Firebase Storage: companies/{id_empresa}/clients/{id_cliente}/profile.jpg
                    const storageRef = ref(storage, `companies/${currentCompanyId}/clients/${currentClientId}/profile.jpg`);
                    console.log(`[CLIENTE-APP] Subindo foto de perfil para: ${storageRef.fullPath}`);
                    showToast('Atualizando foto...', false); // Feedback

                    // 2. Sobe o arquivo (o 'blob' já vem recortado)
                    await uploadBytes(storageRef, blob);

                    // 3. Obtém a URL de download da imagem subida
                    const downloadURL = await getDownloadURL(storageRef);
                    console.log(`[CLIENTE-APP] Foto de perfil subida com sucesso. URL: ${downloadURL}`);

                    // 4. Salva a NOVA URL no documento do cliente no Firestore
                    //    (A rota do Firestore já foi corrigida na Tarefa CL3)
                    const clientDocRef = doc(db, 'companies', currentCompanyId, 'clients', currentClientId);
                    await updateDoc(clientDocRef, { profilePictureUrl: downloadURL });

                    showToast(translations[currentLang].picUpdateSuccess); // Mensagem de sucesso

                } catch (error) { // Captura erros do Storage ou do Firestore
                    console.error("[CLIENTE-APP] Erro ao atualizar foto de perfil (Storage/Firestore):", error);
                    // Tenta dar um feedback mais específico do erro
                    let errorMsg = translations[currentLang].picUpdateError; // Mensagem genérica
                     if (error.code && error.code.startsWith('storage/')) { // Erro do Storage
                        errorMsg = `Erro no envio da foto: ${error.code}`;
                     } else if (error.code) { // Erro do Firestore
                         errorMsg = `Erro ao salvar URL: ${error.code}`;
                     }
                    showToast(errorMsg, true); // Mostra o erro ao usuário
                } finally {
                    // Garante que o estado visual de 'loading' seja removido da imagem de perfil
                    if(profileViewImg) profileViewImg.classList.remove('loading');
                }
                // --- Fim do Bloco TRY/CATCH ---

            // *** ESTA É A CHAVE '}' CORRIGIDA QUE FECHA O CALLBACK async (blob) => { ... } ***
            }, 'image/jpeg', 0.9); // Fim dos argumentos de toBlob
        }); // Fim do listener do confirmBtn
    } else {
         console.error("Botão #confirmCropBtn não encontrado após recriar modal.");
    }
}
// --- FIM: REEMPLAZO COMPLETO CORREGIDO (v2) TAREFA CL5 (showCropperModal) ---
        
        async function handleClearNotifications() {
    if (!currentClient || !currentClientId || !currentCompanyId) return; // Adiciona verificação de IDs
    try {
        // --- INÍCIO TAREFA CL3 (Limpar Notifs) ---
        const clientRef = doc(db, 'companies', currentCompanyId, 'clients', currentClientId); // <-- ROTA NOVA
        // --- FIM TAREFA CL3 ---
        await updateDoc(clientRef, {
            notifications: []
        });
        showToast(translations[currentLang].notificationsCleared);
            } catch (error) {
                console.error("Error clearing notifications:", error);
                showToast(translations[currentLang].genericError, true);
            }
        }
        
        function copyToClipboard(text, message) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showToast(message || translations[currentLang].copied);
                } else {
                    showToast('Falha ao copiar.', true);
                }
            } catch (err) {
                showToast('Falha ao copiar.', true);
            }
            document.body.removeChild(textArea);
        }

        function setupEventListeners() {
            const appContainer = document.getElementById('app-container');
            if(!appContainer) return;

            appContainer.addEventListener('click', e => {
                const target = e.target;
                if (target.closest('#theme-toggle')) {
                    const newTheme = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
                    localStorage.setItem('theme', newTheme);
                    applyTheme(newTheme);
                }
                if (target.closest('#header-profile-link')) {
            location.hash = 'profile'; // Cambia el hash
            showView('profile'); // <-- [NUEVA LÍNEA] Llama explícitamente a showView
        }
                const langToggle = document.getElementById('lang-toggle');
                const langDropdown = document.getElementById('lang-dropdown');
                if (langToggle && target.closest('#lang-toggle')) {
                    e.stopPropagation(); // Evita que el listener de appContainer cierre el dropdown
                    langDropdown.style.display = langDropdown.style.display === 'block' ? 'none' : 'block';
                } else if(langDropdown) {
                    // Cierra el dropdown si se hace clic fuera de él
                    if (!target.closest('#lang-dropdown')) {
                        langDropdown.style.display = 'none';
                    }
                }
                
                const langButton = target.closest('[data-lang]');
                if (langButton) {
                    const newLang = langButton.dataset.lang;
                    localStorage.setItem('language', newLang);
                    currentLang = newLang; // Actualiza la variable global PRIMERO
                    updateAllViews();      // LUEGO, refresca todas las vistas (incluido el historial)
                    
                    if (langDropdown) langDropdown.style.display = 'none';
                }

                const loanTab = target.closest('.loan-tab');
                if (loanTab && loanTab.dataset.index) {
                    const newIndex = parseInt(loanTab.dataset.index, 10);
                    if (newIndex !== selectedLoanIndex) {
                        selectedLoanIndex = newIndex;
                        updateAllViews();
                    }
                }

                const navItem = target.closest('.nav-item');
        if (navItem) {
            if (navItem.classList.contains('disabled')) {
                showToast(translations[currentLang].loanFinished);
                return;
            }
            const targetView = navItem.dataset.view;
            location.hash = targetView; // Cambia el hash
            showView(targetView); // <-- [NUEVA LÍNEA] Llama explícitamente a showView
        }
                


                if(target.closest('#logout-btn')) handleLogout();
                
                if(target.closest('#test-push-btn')) {
                    console.log('[CLIENTE-APP] Botón de Test PUSH presionado. Enviando notificación de prueba...');
                    sendNotificationTicket('Notificación de Prueba', 'Si recibes esto, ¡las notificaciones PUSH funcionan!', 'test', 'check-circle');
                    showToast('Notificación de prueba enviada. Pon la app en segundo plano para verla.');
                }
                
                if(target.closest('#clear-notifications-btn')) {
                    handleClearNotifications();
                }

                const copyButton = target.closest('.copy-btn');
                if(copyButton && copyButton.dataset.copy) {
                    copyToClipboard(copyButton.dataset.copy, translations[currentLang].copied);
                }
                
                // --- [INICIO DE LA CORRECCIÓN] ---
                // Se elimina el listener de '#submit-receipt-btn' de esta función global.
                // La función 'updatePayView' (a través de 'setupPaymentFormListeners')
                // es ahora la única responsable de manejar el clic de envío.
                /*
                if(target.closest('#submit-receipt-btn')) {
                    handleReceiptSubmission(target.closest('#submit-receipt-btn'));
                }
                */
                // --- [FIN DE LA CORRECCIÓN] ---

                const notifItem = target.closest('.notification-item.unread');
                if (notifItem && notifItem.dataset.id) {
                if (currentClient && currentClientId && currentCompanyId) { // Adiciona verificação de IDs
                    // --- INÍCIO TAREFA CL3 (Notif Lida) ---
                    const clientRef = doc(db, 'companies', currentCompanyId, 'clients', currentClientId); // <-- ROTA NOVA
                    // --- FIM TAREFA CL3 ---
                    const updatedNotifications = (currentClient.notifications || []).map((n, index) => { // Garante que notifications existe
                        const currentNotifId = n.id || `notif_${index}`;
                        if (currentNotifId === notifItem.dataset.id) {
                            return { ...n, read: true };
                        }
                        return n;
                    });
                    updateDoc(clientRef, { notifications: updatedNotifications })
                        .then(() => showToast(translations[currentLang].notificationRead))
                        .catch(err => console.error("Error marking notification as read", err));
                }
                }
            });
            appContainer.addEventListener('change', e => {
                if (e.target.id === 'profile-pic-input' && e.target.files && e.target.files[0]) {
                    showCropperModal(e.target.files[0]);
                }
                // --- [INICIO DE LA CORRECCIÓN] ---
                // Esta escucha también es redundante y puede causar problemas
                // si 'updatePayView' no se ha ejecutado.
                // La escucha de 'receipt-file-input' también se maneja
                // dentro de 'setupPaymentFormListeners' en 'updatePayView'.
                /*
                if (e.target.id === 'receipt-file-input' && e.target.files && e.target.files[0]) {
                    receiptFile = e.target.files[0];
                    const preview = document.getElementById('receipt-preview');
                    const uploadLabel = document.getElementById('upload-label-text');
                    preview.src = URL.createObjectURL(receiptFile);
                    preview.style.display = 'block';
                    uploadLabel.style.display = 'none';
                    document.getElementById('submit-receipt-btn').disabled = false;
                }
                */
                // --- [FIN DE LA CORRECCIÓN] ---
            });
        }
        


        // BLOQUE PARA PEGAR EN: app_cliente.html

// BLOQUE 1/2 PARA PEGAR EN: app_cliente.html

async function sendNotificationToCollector(title, body, type = 'payment', icon = 'info', loanIndex = -1, historyIndex = -1) {
    // Verifica que tengamos el ID (username) del cobrador y el ID del cliente
    if (!currentCollectorId || !currentClientId) {
        console.warn("[CLIENTE->COBRADOR] No se puede enviar notificación: IDs no disponibles.");
        return;
    }

    try {
        // 1. Notificación INTERNA (igual que antes)
        const notificationsCollectionRef = collection(db, 'collectors', currentCollectorId, 'notifications');
        const notificationData = {
            title: title,
            body: body,
            from: currentClient?.name || 'Cliente Desconhecido',
            clientId: currentClientId, // Incluye el ID del cliente que envía
            timestamp: serverTimestamp(), // Fecha/hora del servidor
            read: false,
            type: type,
            icon: icon,
            profilePictureUrl: currentClient?.profilePictureUrl || '',
            // --- [CAMBIO CLAVE] ---
            // Añadimos los índices para que el cobrador sepa qué pago aprobar
            loanIndex: loanIndex,
            historyIndex: historyIndex
            // --- [FIN CAMBIO CLAVE] ---
        };
        console.log(`[CLIENTE->COBRADOR] Enviando notificación INTERNA a: collectors/${currentCollectorId}/notifications`);
        await addDoc(notificationsCollectionRef, notificationData);
        console.log(`[CLIENTE->COBRADOR] Notificación INTERNA enviada com índices (L:${loanIndex}, H:${historyIndex}).`);

        // 2. [LÓGICA PUSH AÑADIDA] Ticket PUSH para el COBRADOR
        //    (Esta parte ya estaba correcta, pero la mantenemos)
        const collectorTicketRef = collection(db, 'collectors', currentCollectorId, 'pushNotificationTickets');
        
        const ticketData = {
            title: title,
            body: body,
            type: type, // 'payment', 'refinance'
            icon: icon, // El SW del cobrador espera 'icon'
            url: `https://lumix-financas-app.web.app/collector/index.html?page=client-details&clientId=${currentClientId}`,
            senderClientId: currentClientId,
            senderClientName: currentClient?.name || 'Cliente Desconhecido',
            createdAt: serverTimestamp(),
            // --- [CAMBIO CLAVE] ---
            // Añadimos los índices al TICKET PUSH también
            // (Aunque el SW no los usa, es bueno tenerlos por consistencia)
            loanIndex: loanIndex,
            historyIndex: historyIndex
        };
        console.log(`[CLIENTE->COBRADOR] Creando ticket PUSH en: collectors/${currentCollectorId}/pushNotificationTickets`);
        await addDoc(collectorTicketRef, ticketData);
        console.log(`[CLIENTE->COBRADOR] Ticket PUSH para el cobrador creado.`);

    } catch (error) {
        console.error(`[CLIENTE->COBRADOR] ERROR al enviar notificación/ticket al cobrador:`, error);
    }
}


        
    // BLOQUE 2/2 PARA PEGAR EN: app_cliente.html

    async function handleReceiptSubmission(button) {
            // Verifica si tenemos los datos necesarios (IDs globales) y el archivo seleccionado
            if (!receiptFile || !currentClient || !currentClientId || !currentCompanyId) {
                console.warn("[CLIENTE-APP] Faltan datos (IDs o archivo) para enviar recibo.");
                showToast(translations[currentLang].uploadError, true); // Mensaje genérico si faltan datos
                return;
            }
        
            const amountInput = document.getElementById('receipt-amount');
            const amount = parseFloat(amountInput.value);
        
            // Validación del monto ingresado
            if (isNaN(amount) || amount <= 0) {
                 showToast(translations[currentLang].invalidAmount, true);
                 // Estilo visual de error para el input
                 if(amountInput) amountInput.style.borderColor = 'var(--danger-color)';
                 setTimeout(() => { if(amountInput) amountInput.style.borderColor = ''; }, 2500);
                 return;
            }
        
            // Deshabilita el botón y muestra un indicador de carga
            const originalButtonHTML = button.innerHTML;
            button.disabled = true;
            button.innerHTML = `<i data-lucide="loader-circle" style="animation: spin 1s linear infinite;"></i>`;
            lucide.createIcons({nodes: [button.querySelector('i')]}); // Asegúrate de crear el icono
        
            let receiptUrl = ''; // Variable para guardar la URL del archivo subido
        
            // --- Bloque TRY/CATCH para el UPLOAD al Firebase Storage (SIN CAMBIOS) ---
            try {
                const uniqueFileName = `receipt_${Date.now()}_${receiptFile.name.replace(/\s+/g, '_')}`;
                const storageRef = ref(storage, `companies/${currentCompanyId}/clients/${currentClientId}/receipts/${uniqueFileName}`);
                console.log(`[CLIENTE-APP] Subiendo recibo para: ${storageRef.fullPath}`);
                showToast('Enviando comprovante...', false);
                await uploadBytes(storageRef, receiptFile);
                receiptUrl = await getDownloadURL(storageRef);
                console.log(`[CLIENTE-APP] Recibo subido com sucesso. URL: ${receiptUrl}`);
            } catch (storageError) {
                console.error("[CLIENTE-APP] Erro ao subir recibo para Firebase Storage:", storageError);
                let errorMsg = translations[currentLang].uploadError;
                if (storageError.code === 'storage/unauthorized') { errorMsg = "Erro de permissão ao enviar."; }
                showToast(errorMsg, true);
                button.disabled = false;
                button.innerHTML = originalButtonHTML;
                const icon = button.querySelector('[data-lucide]');
                if(icon) lucide.createIcons({nodes: [icon]});
                return;
            }
            // --- Fin del Bloque TRY/CATCH del Upload ---
        
            // --- Bloque TRY/CATCH para GUARDAR la URL y datos en Firestore ---
            try {
                // --- [INICIO DE LA MODIFICACIÓN] ---
                // Obtener el loanIndex del botón en lugar de la variable global
                const loanIndexToPay = parseInt(button.dataset.loanIndex, 10);
                
                if (isNaN(loanIndexToPay)) {
                    console.error("[CLIENTE-APP] ¡Error fatal! loanIndex no se encontró en el botón de envío.");
                    showToast("Error de referencia del préstamo. Intente de nuevo.", true);
                    button.disabled = false;
                    button.innerHTML = originalButtonHTML;
                    return; // Salir
                }
                console.log(`[CLIENTE-APP] handleReceiptSubmission: Aplicando pago al préstamo índice ${loanIndexToPay}`);
                // --- [FIN DE LA MODIFICACIÓN] ---

                const clientRef = doc(db, 'companies', currentCompanyId, 'clients', currentClientId);
                const updatedLoans = JSON.parse(JSON.stringify(currentClient.loans || []));
        
                const newPayment = {
                    amount: amount,
                    date: new Date(),
                    receiptUrl: receiptUrl,
                    status: 'pending_verification',
                    method: 'receipt'
                };
        
                // --- [INICIO DE LA MODIFICACIÓN] ---
                // Usar loanIndexToPay en lugar de selectedLoanIndex
                if (loanIndexToPay < 0 || loanIndexToPay >= updatedLoans.length) {
                    throw new Error("Índice de préstamo selecionado inválido ao salvar recibo.");
                }
                if (!updatedLoans[loanIndexToPay]) updatedLoans[loanIndexToPay] = { history: []};
                if (!updatedLoans[loanIndexToPay].history) updatedLoans[loanIndexToPay].history = [];
        
                const newHistoryIndex = updatedLoans[loanIndexToPay].history.length;
                updatedLoans[loanIndexToPay].history.push(newPayment);
                // --- [FIN DE LA MODIFICACIÓN] ---
        
                await updateDoc(clientRef, { loans: updatedLoans });
        
                showToast(translations[currentLang].receiptSent);
        
                // --- [INICIO DE LA MODIFICACIÓN] ---
                // Pasar los índices correctos a la notificación
                sendNotificationToCollector(
                    `${currentClient.name || 'Cliente'}`,
                    `${translations[currentLang].paymentSent} ${money(amount)}.`,
                    'payment',
                    'receipt',
                    loanIndexToPay,   // <-- Usar el índice del botón
                    newHistoryIndex   // <-- Usar el índice calculado
                );
                // --- [FIN DE LA MODIFICACIÓN] ---
        
                // Limpia el formulario
                receiptFile = null;
                const fileInput = document.getElementById('receipt-file-input');
                if(fileInput) fileInput.value = '';
                const previewImg = document.getElementById('receipt-preview');
                const uploadLabel = document.getElementById('upload-label-text');
                if(previewImg) previewImg.style.display = 'none';
                if(uploadLabel) uploadLabel.style.display = 'block';
                if(amountInput) amountInput.value = '';
                button.disabled = true; // Se queda deshabilitado tras el éxito
                button.innerHTML = originalButtonHTML;
        
                // Navega de vuelta a la pantalla principal (home)
                location.hash = 'home';
                showView('home');
        
            } catch (firestoreError) {
                 console.error("[CLIENTE-APP] Erro ao salvar dados do recibo no Firestore:", firestoreError);
                 showToast('Erro ao registrar o comprovante no sistema.', true);
                 button.disabled = false;
                 button.innerHTML = originalButtonHTML;
                 const icon = button.querySelector('[data-lucide]');
                 if(icon) lucide.createIcons({nodes: [icon]});
            }
        }






        function loadGlobalSettings(settings) {
            const companyLogo = settings.companyLogo || DEFAULT_LOGO_URL;
            document.getElementById('splash-logo').src = companyLogo;
            document.getElementById('login-logo').src = companyLogo;
            const headerLogo = document.getElementById('header-logo');
            if(headerLogo) headerLogo.src = companyLogo;
        }

        
        async function handleLogin(e) {
            e.preventDefault();
            
            // [CAMBIO] El ID 'username' ahora se trata como un 'username' real
            const usernameInput = document.getElementById('username');
            const passwordInput = document.getElementById('password');
            
            const username = usernameInput.value.trim(); // 1. Obtiene el 'username' (ej: 'maria_perez')
            const password = passwordInput.value;

            // [CAMBIO] Construye el email con el sufijo @gmail.com
            const email = `${username}@gmail.com`; 

            // --- (El resto del código de manejo del botón es idéntico al original) ---
            const loginBtn = document.querySelector('#login-form button');
            const originalBtnHTML = loginBtn.innerHTML;
            loginBtn.disabled = true;
            loginBtn.innerHTML = `<i data-lucide="loader-circle" style="animation: spin 1s linear infinite;"></i>`;
            lucide.createIcons({ nodes: [loginBtn.querySelector('i')] });
            // --- (Fin del código del botón) ---

            try {
                // [CAMBIO] Inicia sesión con el 'email' construido
                console.log(`[CLIENTE-APP] Tentando login com email construído: ${email}`);
                await signInWithEmailAndPassword(auth, email, password);

                // SUCESSO! O onAuthStateChanged vai ser chamado automaticamente
                console.log("[CLIENTE-APP] signInWithEmailAndPassword bem-sucedido. Aguardando onAuthStateChanged...");

            } catch (error) {
                // FALHA no login
                console.error("[CLIENTE-APP] Erro de login (signInWithEmailAndPassword):", error.code, error.message);
                
                let errorMsgKey = 'genericError';
                if (error.code === 'auth/invalid-credential' || error.code === 'auth/wrong-password' || error.code === 'auth/user-not-found') {
                    errorMsgKey = 'invalidCredentials';
                
                // [CAMBIO] Mensaje de error actualizado
                } else if (error.code === 'auth/invalid-email') {
                     showToast('Usuário inválido (não pode conter @ ou espaços).', true);
                     errorMsgKey = null; // No muestra toast genérico
                } else if (error.code === 'auth/too-many-requests') {
                     showToast('Muitas tentativas falhadas. Tente novamente mais tarde.', true);
                     errorMsgKey = null;
                }

                if (errorMsgKey) showToast(translations[currentLang][errorMsgKey], true);

                // --- (Restaurar el botón en error, idéntico al original) ---
                loginBtn.disabled = false;
                loginBtn.innerHTML = originalBtnHTML;
                 // Re-aplica el idioma al botón (necesario si el originalBtnHTML era solo la key)
                applyLanguage(currentLang); 
                // --- (Fin de restaurar botón) ---
            }
        }


        
        function init() {
    // --- Service Worker Registration (SEM ALTERAÇÕES) ---
    if ('serviceWorker' in navigator) {
      if (location.protocol === 'https:' || location.hostname === 'localhost') {
        navigator.serviceWorker.register('firebase-messaging-sw.js') // Certifique-se que o nome do arquivo está correto
          .then(function(registration) {
            console.log('[CLIENTE-APP] Service Worker registrado com sucesso:', registration);
          }).catch(function(error) {
            console.log('[CLIENTE-APP] Error ao registrar o Service Worker:', error);
          });
      } else {
          console.warn('[CLIENTE-APP] Service Worker não registrado. O ambiente não é seguro (HTTPS) ou não é localhost.');
      }
    }

    // --- Popstate listener (SEM ALTERAÇÕES) ---
    window.addEventListener('popstate', () => { /* ... (código existente) ... */ });

    // --- Lógica do Banner PWA (SEM ALTERAÇÕES) ---
    window.addEventListener('beforeinstallprompt', (e) => { /* ... (código existente) ... */ });
    const installBtn = document.getElementById('install-btn');
    if (installBtn) { /* ... (código existente) ... */ }
    const closeInstallBtn = document.getElementById('close-install-banner');
    if (closeInstallBtn) { /* ... (código existente) ... */ }

    // --- Aplica tema e idioma iniciais (SEM ALTERAÇÕES) ---
    const preferredTheme = localStorage.getItem('theme') || 'dark';
    applyTheme(preferredTheme);
    applyLanguage(currentLang);

    // --- INÍCIO TAREFA CL0/CL1: NOVA LÓGICA DE AUTENTICAÇÃO ---
    const splash = document.getElementById('splash-screen');
    loadGlobalSettings({}); // Carrega logo padrão enquanto autentica

    onAuthStateChanged(auth, async (user) => {
        splash.style.opacity = '0';
        setTimeout(() => splash.style.display = 'none', 500);

        if (user) {
            // Usuário logado via Firebase Auth
            try {
            console.log("[CLIENTE-APP][DIAG] PASO 1: Verificando permissões..."); // <--- LOG 1
            
            // const tokenResult = await user.getIdTokenResult(true); // <--- [CORRECCIÓN] LÍNEA ELIMINADA. ESTA LÍNEA CAUSABA EL BUCLE INFINITO.

            console.log("[CLIENTE-APP][DIAG] PASO 2: Permissões OK. Buscando documento do cliente..."); // <--- LOG 2
            currentAuthUid = user.uid;
            const clientQuery = query(collectionGroup(db, 'clients'), where('authUid', '==', currentAuthUid));
            const querySnapshot = await getDocs(clientQuery);

            console.log("[CLIENTE-APP][DIAG] PASO 3: Busca CollectionGroup concluída."); // <--- LOG 3
            if (querySnapshot.empty) {
                console.error("[CLIENTE-APP][DIAG] ERRO no PASO 3.1: Nenhum cliente encontrado."); // <--- AÑADIR LOG
                throw new Error("Nenhum registro de cliente encontrado para esta conta. Contate o suporte.");
            }
            if (querySnapshot.size > 1) {
                console.warn("[CLIENTE-APP][DIAG] AVISO no PASO 3.2: Múltiplos clientes encontrados!"); // <--- AÑADIR LOG
            }

            const clientDoc = querySnapshot.docs[0];
            console.log("[CLIENTE-APP][DIAG] PASO 4: Documento do cliente obtido:", clientDoc.id); // <--- AÑADIR LOG

            // --- Asignaciones ---
            

            // PASO CL1: Obtener IDs y Datos del CLIENTE
            console.log("[CLIENTE-APP][DIAG-V3] PASO 5.1: Obtendo IDs...");
            currentClientId = clientDoc.id; // ID del Documento Firestore del Cliente
            currentCompanyId = clientDoc.ref.parent.parent.id; // ID de la Empresa (desde la ruta)

            console.log("[CLIENTE-APP][DIAG-V3] PASO 5.2: Lendo dados do cliente...");
            let clientDataFromDb;
            try {
                clientDataFromDb = clientDoc.data(); // Lee los datos
            } catch (dataError) {
                console.error("[CLIENTE-APP][DIAG-V3] ERRO no PASO 5.2.1: Falha ao ler clientDoc.data()!", dataError);
                throw new Error(`Falha ao ler dados do cliente (${clientDoc.id}): ${dataError.message}`);
            }
            if (!clientDataFromDb) {
                console.error("[CLIENTE-APP][DIAG-V3] ERRO no PASO 5.2.2: clientDoc.data() retornou vazio.");
                throw new Error(`Dados do cliente (${clientDoc.id}) estão vazios ou corruptos.`);
            }
            console.log("[CLIENTE-APP][DIAG-V3] PASO 5.2.3: clientDoc.data() lido com sucesso.");

            // Guarda los datos del CLIENTE en la variable global 'currentClient' (usada por el resto de la app)
            // Usamos 'currentClient' en lugar de 'currentClientData' para evitar conflictos.
            currentClient = { id: currentClientId, ...clientDataFromDb };
            console.log("[CLIENTE-APP][DIAG-V3] PASO 5.3: Variável global 'currentClient' atribuída:", currentClient);

            // Obtén el collectorId DESDE 'currentClient' que acabamos de definir
            currentCollectorId = currentClient.collectorId;
            if (currentCollectorId === undefined) {
                 console.warn(`[CLIENTE-APP][DIAG-V3] AVISO no PASO 5.4: Campo 'collectorId' não encontrado no cliente.`);
                 // Considera si esto debe ser un error o si puede continuar
            }
            console.log(`[CLIENTE-APP] IDs Obtidos: ClientID=${currentClientId}, CompanyID=${currentCompanyId}, CollectorID=${currentCollectorId}`);


            // PASO CL2: Obtener Datos y Verificar Status da EMPRESA
            console.log(`[CLIENTE-APP][DIAG-V3] PASO 6: Verificando status da empresa: ${currentCompanyId}...`);
            const companyRef = doc(db, 'companies', currentCompanyId);
            const companySnap = await getDoc(companyRef);

            if (!companySnap.exists()) {
                console.error("[CLIENTE-APP][DIAG-V3] ERRO no PASO 6.1: Documento da empresa não existe.");
                throw new Error(`Erro crítico: A empresa (${currentCompanyId}) associada a este cliente não foi encontrada.`);
            }

            // Guarda los datos de la EMPRESA en la variable global 'currentCompanyData'
            currentCompanyData = companySnap.data();
            console.log("[CLIENTE-APP][DIAG-V3] PASO 6.2: Dados da empresa ('currentCompanyData') obtidos.");

            // Verificación de STATUS usando 'currentCompanyData' (que ahora sí tiene datos de la empresa)
            if (currentCompanyData.status === 'suspended') {
                const errorMsg = `A conta da sua empresa (${currentCompanyData.name || 'Nome não disponível'}) está suspensa...`;
                console.warn(`[CLIENTE-APP] ${errorMsg}`);
                showBlockedView(errorMsg);
                return; // Detiene aquí si está suspendida
            }
            console.log(`[CLIENTE-APP] Empresa ${currentCompanyData.name} está ativa (Status: ${currentCompanyData.status}).`);

            // Aplica logo/nome da EMPRESA usando 'currentCompanyData'
            loadGlobalSettings(currentCompanyData);
            console.log("[CLIENTE-APP][DIAG-V3] PASO 7: Configurações globais (logo/nome) aplicadas.");

            // --- FIN: CORRECCIÓN DEFINITIVA TAREAS CL1 y CL2 ---



            console.log("[CLIENTE-APP][DIAG] PASO 11: Chamando showMainApp..."); // <--- AÑADIR LOG
            showMainApp(currentClientId, currentCompanyId);

        } catch (error) { // <-- Bloque Catch original
            // El console.error original ya está aquí (linha ~1758)
            console.error("[CLIENTE-APP] Erro crítico durante a verificação de acesso:", error);
            // El showBlockedView original ya está aquí (linha ~1759)
            showBlockedView(`Ocorreu um erro ao verificar sua conta: ${error.message}`);
            // El signOut original ya está aquí (linha ~1760)
            await signOut(auth).catch(e => console.error("Erro no signOut forçado:", e));
        }

        } else {
            // Usuário NÃO está logado no Firebase Auth
            console.log("[CLIENTE-APP] Nenhum usuário Firebase Auth logado. Mostrando tela de login.");
            // Limpa variáveis globais caso tenha havido logout
            currentAuthUid = null;
            currentClientId = null;
            currentCompanyId = null;
            currentCollectorId = null;
            currentClient = null; // Limpa dados do cliente anterior
            collectorSettings = null; // Limpa dados do cobrador anterior

            document.getElementById('app-container').style.display = 'none';
            document.getElementById('login-view').style.display = 'flex';

            const loginBtn = document.querySelector('#login-form button[type="submit"]');
            if (loginBtn) {
                loginBtn.disabled = false;
                // Restauramos el innerHTML para que esté vacío.
                // La función 'applyLanguage' (que se llama más abajo) se encargará de rellenar
                // el texto correcto usando el 'data-lang-key' del botón.
                loginBtn.innerHTML = ''; 
            }

            // Garante que o listener do formulário de login (que usará Firebase Auth) seja adicionado
            const loginForm = document.getElementById('login-form');
            if (loginForm) {
                loginForm.removeEventListener('submit', handleLogin); // Remove o antigo se existir
                loginForm.addEventListener('submit', handleLogin); // Adiciona o novo
            }
            applyLanguage(currentLang); // Aplica idioma na tela de login
        }
    });
}
init();



    </script>
</body>
</html>

